use rug::{Integer as Int, Float};

use std::str::FromStr;

use crate::ast;

grammar;

/// https://doc.rust-lang.org/reference/tokens.html
match {
    r"///[^\n]*\n" => Docstring,
} else {
    r"//[^\n]*\n" => { },
    r"\s*" => { },
} else {
    "as" => TokAs,
    "break" => TokBreak,
    "const" => TokConst,
    "continue" => TokContinue,
    "crate" => TokCrate,
    "else" => TokElse,
    "enum" => TokEnum,
    "extern" => TokExtern,
    "fn" => TokFn,
    "for" => TokFor,
    "if" => TokIf,
    "impl" => TokImpl,
    "in" => TokIn,
    "let" => TokLet,
    "loop" => TokLoop,
    "match" => TokMatch,
    "mod" => TokMod,
    "move" => TokMove,
    "mut" => TokMut,
    "pub" => TokPub,
    "ref" => TokRef,
    "return" => TokReturn,
    "self" => TokLowerSelf,
    "Self" => TokUpperSelf,
    "static" => TokStatic,
    "struct" => TokStruct,
    "super" => TokSuper,
    "trait" => TokTrait,
    "type" => TokTokenType,
    "unsafe" => TokUnsafe,
    "use" => TokUse,
    "where" => TokWhere,
    "while" => TokWhile,

    "async" => TokAsync,
    "await" => TokAwait,
    "dyn" => TokDyn,

    "abstract" => TokAbstract,
    "become" => TokBecome,
    "box" => TokBox,
    "do" => TokDo,
    "final" => TokFinal,
    "macro" => TokMacro,
    "override" => TokOverride,
    "priv" => TokPriv,
    "typeof" => TokTypeof,
    "unsized" => TokUnsized,
    "virtual" => TokVirtual,
    "yield" => TokYield,
    "try" => TokTry,

    "union" => TokUnion,

    "entity" => TokEntity,
    "bag" => TokBag,
    "ring" => TokRing,
    "arch" => TokArch,
    "when" => TokWhen,
    "out" => TokOut,
    "inout" => TokInOut,

    "+" => TokPlus,
    "-" => TokMinus,
    "*" => TokStar,
    "**" => TokStarStar,
    "/" => TokSlash,
    "%" => TokPercent,
    "^" => TokCaret,
    "!" => TokNot,
    "&" => TokAnd,
    "|" => TokOr,
    "&&" => TokAndAnd,
    "||" => TokOrOr,
    "<<" => TokShl,
    ">>" => TokShr,
    "+=" => TokPlusEq,
    "-=" => TokMinusEq,
    "*=" => TokStarEq,
    "**=" => TokStarStarEq,
    "/=" => TokSlashEq,
    "%=" => TokPercentEq,
    "^=" => TokCaretEq,
    "&=" => TokAndEq,
    "|=" => TokOrEq,
    "<<=" => TokShlEq,
    ">>=" => TokShrEq,
    "=" => TokEq,
    "==" => TokEqEq,
    "!=" => TokNe,
    ">" => TokGt,
    "<" => TokLt,
    ">=" => TokGe,
    "<=" => TokLe,
    "@" => TokAt,
    "_" => TokUnderscore,
    "." => TokDot,
    ".." => TokDotDot,
    "..=" => TokDotDotEq,
    "," => TokComma,
    ";" => TokSemi,
    ":" => TokColon,
    "::" => TokPathSep,
    "->" => TokRArrow,
    "=>" => TokFatArrow,
    "#" => TokPound,
    "$" => TokDollar,
    "?" => TokQuestion,
    "[" => TokBracketOpen,
    "]" => TokBracketClose,
    "(" => TokParenOpen,
    ")" => TokParenClose,
    "{" => TokBraceOpen,
    "}" => TokBraceClose,

    "r#crate" => RawCrate,
    "r#self" => RawLowerSelf,
    "r#Self" => RawUpperSelf,
    "r#super" => RawSuper,
    r"(0|[1-9]\d*)" => Integer,
    r"(true|false)" => Boolean,
} else {
    r"(?:[a-zA-Z][a-zA-Z0-9_]*|_[a-zA-Z0-9_]+)" => NonKeywordIdentifier,
    r"r#(?:[a-zA-Z][a-zA-Z0-9_]*|_[a-zA-Z0-9_]+)" => RawIdentifier,
    r"(0|[1-9]\d*(?:_\d+)*)" => IntegerForLiteral,
    r"0d\d+(?:_\d+)*" => DecimalInteger,
    r"0x[0-9a-fA-F]+(?:_[0-9a-fA-F]+)*" => HexInteger,
    r"0o[0-7]+(?:_[0-7]+)*" => OctalInteger,
    r"0b[01]+(?:_[01]+)*" => BinaryInteger,
    r"(?:2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36)#[a-zA-Z0-9]+(?:_[a-zA-Z0-9]+)*" => BaseInteger,
    r"(?:\d+\.\d*|\d*\.\d+|\d+)(?:[eE][-+]?\d+)?f(?:16|32|64|80|128|256)" => FloatingPoint,
}

#[inline] As: ast::token::As = <left:@L> TokAs => ast::token::As { left };
#[inline] Break: ast::token::Break = <left:@L> TokBreak => ast::token::Break { left };
#[inline] Const: ast::token::Const = <left:@L> TokConst => ast::token::Const { left };
#[inline] Continue: ast::token::Continue = <left:@L> TokContinue => ast::token::Continue { left };
#[inline] Crate: ast::token::Crate = <left:@L> TokCrate => ast::token::Crate { left };
#[inline] Else: ast::token::Else = <left:@L> TokElse => ast::token::Else { left };
#[inline] Enum: ast::token::Enum = <left:@L> TokEnum => ast::token::Enum { left };
#[inline] Extern: ast::token::Extern = <left:@L> TokExtern => ast::token::Extern { left };
#[inline] Fn: ast::token::Fn = <left:@L> TokFn => ast::token::Fn { left };
#[inline] For: ast::token::For = <left:@L> TokFor => ast::token::For { left };
#[inline] If: ast::token::If = <left:@L> TokIf => ast::token::If { left };
#[inline] Impl: ast::token::Impl = <left:@L> TokImpl => ast::token::Impl { left };
#[inline] In: ast::token::In = <left:@L> TokIn => ast::token::In { left };
#[inline] Let: ast::token::Let = <left:@L> TokLet => ast::token::Let { left };
#[inline] Loop: ast::token::Loop = <left:@L> TokLoop => ast::token::Loop { left };
#[inline] Match: ast::token::Match = <left:@L> TokMatch => ast::token::Match { left };
#[inline] Mod: ast::token::Mod = <left:@L> TokMod => ast::token::Mod { left };
#[inline] Move: ast::token::Move = <left:@L> TokMove => ast::token::Move { left };
#[inline] Mut: ast::token::Mut = <left:@L> TokMut => ast::token::Mut { left };
#[inline] Pub: ast::token::Pub = <left:@L> TokPub => ast::token::Pub { left };
#[inline] Ref: ast::token::Ref = <left:@L> TokRef => ast::token::Ref { left };
#[inline] Return: ast::token::Return = <left:@L> TokReturn => ast::token::Return { left };
#[inline] LowerSelf: ast::token::LowerSelf = <left:@L> TokLowerSelf => ast::token::LowerSelf { left };
#[inline] UpperSelf: ast::token::UpperSelf = <left:@L> TokUpperSelf => ast::token::UpperSelf { left };
#[inline] Static: ast::token::Static = <left:@L> TokStatic => ast::token::Static { left };
#[inline] Struct: ast::token::Struct = <left:@L> TokStruct => ast::token::Struct { left };
#[inline] Super: ast::token::Super = <left:@L> TokSuper => ast::token::Super { left };
#[inline] Trait: ast::token::Trait = <left:@L> TokTrait => ast::token::Trait { left };
#[inline] TokenType: ast::token::TokenType = <left:@L> TokTokenType => ast::token::TokenType { left };
#[inline] Unsafe: ast::token::Unsafe = <left:@L> TokUnsafe => ast::token::Unsafe { left };
#[inline] Use: ast::token::Use = <left:@L> TokUse => ast::token::Use { left };
#[inline] Where: ast::token::Where = <left:@L> TokWhere => ast::token::Where { left };
#[inline] While: ast::token::While = <left:@L> TokWhile => ast::token::While { left };

#[inline] Async: ast::token::Async = <left:@L> TokAsync => ast::token::Async { left };
#[inline] Await: ast::token::Await = <left:@L> TokAwait => ast::token::Await { left };
#[inline] Dyn: ast::token::Dyn = <left:@L> TokDyn => ast::token::Dyn { left };

#[inline] Abstract: ast::token::Abstract = <left:@L> TokAbstract => ast::token::Abstract { left };
#[inline] Become: ast::token::Become = <left:@L> TokBecome => ast::token::Become { left };
#[inline] TokenBox: ast::token::TokenBox = <left:@L> TokBox => ast::token::TokenBox { left };
#[inline] Do: ast::token::Do = <left:@L> TokDo => ast::token::Do { left };
#[inline] Final: ast::token::Final = <left:@L> TokFinal => ast::token::Final { left };
#[inline] Macro: ast::token::Macro = <left:@L> TokMacro => ast::token::Macro { left };
#[inline] Override: ast::token::Override = <left:@L> TokOverride => ast::token::Override { left };
#[inline] Priv: ast::token::Priv = <left:@L> TokPriv => ast::token::Priv { left };
#[inline] Typeof: ast::token::Typeof = <left:@L> TokTypeof => ast::token::Typeof { left };
#[inline] Unsized: ast::token::Unsized = <left:@L> TokUnsized => ast::token::Unsized { left };
#[inline] Virtual: ast::token::Virtual = <left:@L> TokVirtual => ast::token::Virtual { left };
#[inline] Yield: ast::token::Yield = <left:@L> TokYield => ast::token::Yield { left };
#[inline] Try: ast::token::Try = <left:@L> TokTry => ast::token::Try { left };

#[inline] Union: ast::token::Union = <left:@L> TokUnion => ast::token::Union { left };

#[inline] Entity: ast::token::Entity = <left:@L> TokEntity => ast::token::Entity { left };
#[inline] Bag: ast::token::Bag = <left:@L> TokBag => ast::token::Bag { left };
#[inline] Ring: ast::token::Ring = <left:@L> TokRing => ast::token::Ring { left };
#[inline] Arch: ast::token::Arch = <left:@L> TokArch => ast::token::Arch { left };
#[inline] When: ast::token::When = <left:@L> TokWhen => ast::token::When { left };
#[inline] Out: ast::token::Out = <left:@L> TokOut => ast::token::Out { left };
#[inline] InOut: ast::token::InOut = <left:@L> TokInOut => ast::token::InOut { left };

#[inline] Plus: ast::token::Plus = <left:@L> TokPlus => ast::token::Plus { left };
#[inline] Minus: ast::token::Minus = <left:@L> TokMinus => ast::token::Minus { left };
#[inline] Star: ast::token::Star = <left:@L> TokStar => ast::token::Star { left };
#[inline] StarStar: ast::token::StarStar = <left:@L> TokStarStar => ast::token::StarStar { left };
#[inline] Slash: ast::token::Slash = <left:@L> TokSlash => ast::token::Slash { left };
#[inline] Percent: ast::token::Percent = <left:@L> TokPercent => ast::token::Percent { left };
#[inline] Caret: ast::token::Caret = <left:@L> TokCaret => ast::token::Caret { left };
#[inline] Not: ast::token::Not = <left:@L> TokNot => ast::token::Not { left };
#[inline] And: ast::token::And = <left:@L> TokAnd => ast::token::And { left };
#[inline] Or: ast::token::Or = <left:@L> TokOr => ast::token::Or { left };
#[inline] AndAnd: ast::token::AndAnd = <left:@L> TokAndAnd => ast::token::AndAnd { left };
#[inline] OrOr: ast::token::OrOr = <left:@L> TokOrOr => ast::token::OrOr { left };
#[inline] Shl: ast::token::Shl = <left:@L> TokShl => ast::token::Shl { left };
#[inline] Shr: ast::token::Shr = <left:@L> TokShr => ast::token::Shr { left };
#[inline] PlusEq: ast::token::PlusEq = <left:@L> TokPlusEq => ast::token::PlusEq { left };
#[inline] MinusEq: ast::token::MinusEq = <left:@L> TokMinusEq => ast::token::MinusEq { left };
#[inline] StarEq: ast::token::StarEq = <left:@L> TokStarEq => ast::token::StarEq { left };
#[inline] StarStarEq: ast::token::StarStarEq = <left:@L> TokStarStarEq => ast::token::StarStarEq { left };
#[inline] SlashEq: ast::token::SlashEq = <left:@L> TokSlashEq => ast::token::SlashEq { left };
#[inline] PercentEq: ast::token::PercentEq = <left:@L> TokPercentEq => ast::token::PercentEq { left };
#[inline] CaretEq: ast::token::CaretEq = <left:@L> TokCaretEq => ast::token::CaretEq { left };
#[inline] AndEq: ast::token::AndEq = <left:@L> TokAndEq => ast::token::AndEq { left };
#[inline] OrEq: ast::token::OrEq = <left:@L> TokOrEq => ast::token::OrEq { left };
#[inline] ShlEq: ast::token::ShlEq = <left:@L> TokShlEq => ast::token::ShlEq { left };
#[inline] ShrEq: ast::token::ShrEq = <left:@L> TokShrEq => ast::token::ShrEq { left };
#[inline] Eq: ast::token::Eq = <left:@L> TokEq => ast::token::Eq { left };
#[inline] EqEq: ast::token::EqEq = <left:@L> TokEqEq => ast::token::EqEq { left };
#[inline] Ne: ast::token::Ne = <left:@L> TokNe => ast::token::Ne { left };
#[inline] Gt: ast::token::Gt = <left:@L> TokGt => ast::token::Gt { left };
#[inline] Lt: ast::token::Lt = <left:@L> TokLt => ast::token::Lt { left };
#[inline] Ge: ast::token::Ge = <left:@L> TokGe => ast::token::Ge { left };
#[inline] Le: ast::token::Le = <left:@L> TokLe => ast::token::Le { left };
#[inline] At: ast::token::At = <left:@L> TokAt => ast::token::At { left };
#[inline] Underscore: ast::token::Underscore = <left:@L> TokUnderscore => ast::token::Underscore { left };
#[inline] Dot: ast::token::Dot = <left:@L> TokDot => ast::token::Dot { left };
#[inline] DotDot: ast::token::DotDot = <left:@L> TokDotDot => ast::token::DotDot { left };
#[inline] DotDotEq: ast::token::DotDotEq = <left:@L> TokDotDotEq => ast::token::DotDotEq { left };
#[inline] Comma: ast::token::Comma = <left:@L> TokComma => ast::token::Comma { left };
#[inline] Semi: ast::token::Semi = <left:@L> TokSemi => ast::token::Semi { left };
#[inline] Colon: ast::token::Colon = <left:@L> TokColon => ast::token::Colon { left };
#[inline] PathSep: ast::token::PathSep = <left:@L> TokPathSep => ast::token::PathSep { left };
#[inline] RArrow: ast::token::RArrow = <left:@L> TokRArrow => ast::token::RArrow { left };
#[inline] FatArrow: ast::token::FatArrow = <left:@L> TokFatArrow => ast::token::FatArrow { left };
#[inline] Pound: ast::token::Pound = <left:@L> TokPound => ast::token::Pound { left };
#[inline] Dollar: ast::token::Dollar = <left:@L> TokDollar => ast::token::Dollar { left };
#[inline] Question: ast::token::Question = <left:@L> TokQuestion => ast::token::Question { left };
#[inline] BracketOpen: ast::token::BracketOpen = <left:@L> TokBracketOpen => ast::token::BracketOpen { left };
#[inline] BracketClose: ast::token::BracketClose = <left:@L> TokBracketClose => ast::token::BracketClose { left };
#[inline] ParenOpen: ast::token::ParenOpen = <left:@L> TokParenOpen => ast::token::ParenOpen { left };
#[inline] ParenClose: ast::token::ParenClose = <left:@L> TokParenClose => ast::token::ParenClose { left };
#[inline] BraceOpen: ast::token::BraceOpen = <left:@L> TokBraceOpen => ast::token::BraceOpen { left };
#[inline] BraceClose: ast::token::BraceClose = <left:@L> TokBraceClose => ast::token::BraceClose { left };


/// https://doc.rust-lang.org/reference/identifiers.html
Identifier: &'input str = { NonKeywordIdentifier, RawIdentifier };
Ident: ast::token::Ident = <left:@L> <ident:Identifier> <right:@R> => ast::token::Ident {
    inner: ident.to_string(),
    span: ast::Span(left, right),
};

/// i.e. 1_234_567_890
PlainLitInt: ast::token::LitInt = <left:@L> <val:Integer> <right:@R> => ast::token::LitInt { val: Int::parse(val).unwrap().into(), suffix: None, raw: val.to_string(), span: ast::Span(left, right) };

pub LitInt: ast::token::LitInt = {
    PlainLitInt,

    <left:@L> <val:IntegerForLiteral> <right: @R> => {
        ast::token::LitInt {
            val: Int::parse(val).unwrap().into(),
            suffix: None,
            raw: val.to_string(),
            span: ast::Span(left, right),
        }
    },

    // i.e. 0d123
    <left:@L> <val:DecimalInteger> <right: @R> => {
        const BASE_CHAR: char = 'd';
        const BASE: i32 = 10;
        ast::token::LitInt {
            val: Int::parse_radix(&val.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            suffix: None,
            raw: val.to_string(),
            span: ast::Span(left, right),
        }
    },

    // i.e. 0xC0FFEE_CAFE
    <left:@L> <val:HexInteger> <right: @R> => {
        const BASE_CHAR: char = 'x';
        const BASE: i32 = 16;
        ast::token::LitInt {
            val: Int::parse_radix(&val.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            suffix: None,
            raw: val.to_string(),
            span: ast::Span(left, right),
        }
    },

    // i.e. 0o72
    <left:@L> <val:OctalInteger> <right: @R> => {
        const BASE_CHAR: char = 'o';
        const BASE: i32 = 8;
        ast::token::LitInt {
            val: Int::parse_radix(&val.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            suffix: None,
            raw: val.to_string(),
            span: ast::Span(left, right),
        }
    },

    // i.e. 0b00110010_00101011_00110010_00111101_00110101
    <left:@L> <val:BinaryInteger> <right: @R> => {
        const BASE_CHAR: char = 'b';
        const BASE: i32 = 2;
        ast::token::LitInt {
            val: Int::parse_radix(&val.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            suffix: None,
            raw: val.to_string(),
            span: ast::Span(left, right),
        }
    },

    // i.e. 36#HI, an Int in base 36
    <left:@L> <val:BaseInteger> <right: @R> => {
        const BASE_CHAR: char = '#';
        let base = val.split(BASE_CHAR).next().map(i32::from_str).unwrap().unwrap();
        ast::token::LitInt {
            val: Int::parse_radix(&val.split(BASE_CHAR).nth(1).unwrap(), base).unwrap().into(),
            suffix: None,
            raw: val.to_string(),
            span: ast::Span(left, right),
        }
    },
};

pub LitFloat: ast::token::LitFloat = <left:@L> <val:FloatingPoint> <right: @R> => {
    let format = val.split('f').nth(1).map(usize::from_str).unwrap().unwrap();
    let precision = match format {
        16 => 11,
        32 => 24,
        64 => 53,
        80 => 64,
        128 => 113,
        256 => 237,
        _ => unreachable!()
    };
    let float = Float::parse(val.split('f').next().unwrap()).unwrap();
    ast::token::LitFloat {
        val: Float::with_val(precision, float),
        suffix: None,
        raw: val.to_string(),
        span: ast::Span(left, right),
    }
};

LitBool: ast::token::LitBool = <left:@L> <val:Boolean> <right:@R> => {
    let inner = val == "true";
    ast::LitBool { inner, span: ast::Span(left, right) }
};

Lit: ast::token::Lit = {
    LitInt => ast::token::Lit::Int(<>),
    LitFloat => ast::token::Lit::Float(<>),
    LitBool => ast::token::Lit::Bool(<>),
};


PunctCanTrail<T, P>: ast::Punctuated<T, P> = {
    <inner:(T P)*> <last:T?> => {
        ast::Punctuated {
            inner,
            last: last.map(Box::new)
        }
    }
};

PunctMustTrail<T, P>: ast::Punctuated<T, P> = {
    <inner:(T P)*> => {
        ast::Punctuated {
            inner,
            last: None
        }
    }
};

PunctNoTrail<T, P>: ast::Punctuated<T, P> = {
    <inner:(T P)*> <last:T> => {
        ast::Punctuated {
            inner,
            last: Some(Box::new(last))
        }
    }
};

#[inline]
Box<T>: Box<T> = T => Box::new(<>);

/// https://doc.rust-lang.org/reference/paths.html#simple-paths
Path: ast::SimplePath = <leading_sep:PathSep?> <segments:PunctNoTrail<PathSegment, PathSep>> => ast::SimplePath { leading_sep, segments };

#[inline]
PathSegment: ast::token::Ident = {
    Ident,
    <left:@L> <ident:LowerSelf> <right:@R> => ast::token::Ident { inner: ident.to_string(), span: ast::Span(left, right) },
    <left:@L> <ident:Super> <right:@R> => ast::token::Ident { inner: ident.to_string(), span: ast::Span(left, right) },
    <left:@L> <ident:Crate> <right:@R> => ast::token::Ident { inner: ident.to_string(), span: ast::Span(left, right) },
};

pub File: ast::File = Item* => {
    ast::File {
        items: <>
    }
};

ItemConst: ast::ItemConst = <vis:Visibility?> <const_token:Const> <ident:Ident> <colon:Colon> <ty:Type> <eq:Eq> <expr:Expr> <semi:Semi> => ast::ItemConst {
    vis,
    const_token,
    ident,
    colon,
    ty,
    eq,
    expr,
    semi
};
ItemFn: ast::ItemFn = <vis:Visibility?> <fn_token:Fn> <sig:Sig> <block:Block> => ast::ItemFn {
    vis,
    fn_token,
    sig,
    block
};
ItemType: ast::ItemType = <vis:Visibility?> <type_token:TokenType> <ident:Ident> <generics:Generics?> <where_clause:WhereClause?> <eq:Eq> <ty:Type> <semi:Semi> => ast::ItemType {
    vis,
    type_token,
    ident,
    generics,
    eq,
    ty,
    semi
};

/// https://doc.rust-lang.org/reference/items.html
Item: ast::Item = {
    /// https://doc.rust-lang.org/reference/items/modules.html
    <vis:Visibility?> <mod_token:Mod> <ident:Ident> <brace_open:BraceOpen> <items:Item*> <brace_close:BraceClose> => ast::Item::Mod(
        ast::ItemMod {
            vis,
            mod_token,
            ident,
            content: ast::ModContent::Here(
                ast::ModContentHere {
                    brace_open,
                    items,
                    brace_close
                }
            )
        }
    ),
    <vis:Visibility?> <mod_token:Mod> <ident:Ident> <semi:Semi> => ast::Item::Mod(
        ast::ItemMod {
            vis,
            mod_token,
            ident,
            content: ast::ModContent::File(
                ast::ModContentFile { semi }
            )
        }
    ),

    /// https://doc.rust-lang.org/reference/items/use-declarations.html
    <vis:Visibility?> <use_token:Use> <tree:UseTree> <semi:Semi> => ast::Item::Use(
        ast::ItemUse {
            vis,
            use_token,
            tree,
            semi
        }
    ),

    /// https://doc.rust-lang.org/reference/items/constant-items.html
    ItemConst => ast::Item::Const(<>),

    /// https://doc.rust-lang.org/reference/items/functions.html
    ItemFn => ast::Item::Fn(<>),

    /// https://doc.rust-lang.org/reference/items/type-aliases.html
    ItemType => ast::Item::Type(<>),

    /// https://doc.rust-lang.org/reference/items/structs.html
    <vis:Visibility?> <struct_token:Struct> <ident:Ident> <generics:Generics?> <fields:StructFields> => ast::Item::Struct(
        ast::ItemStruct {
            vis,
            struct_token,
            ident,
            generics,
            fields: fields.0,
            semi: fields.1
        }
    ),

    /// https://doc.rust-lang.org/reference/items/enumerations.html
    <vis:Visibility?> <enum_token:Enum> <ident:Ident> <generics:Generics?> <where_clause:WhereClause?> <brace_open:BraceOpen> <variants:PunctCanTrail<Variant, Comma>> <brace_close:BraceClose> => ast::Item::Enum(
        ast::ItemEnum {
            vis,
            enum_token,
            ident,
            generics,
            brace_open,
            variants,
            brace_close
        }
    ),

    <vis:Visibility?> <trait_token:Trait> <ident:Ident> <generics:Generics?> <super_traits:(Colon PunctNoTrail<TypePath, Plus>)?> <where_clause:WhereClause?> <brace_open:BraceOpen> <items:TraitItem*> <brace_close:BraceClose> => ast::Item::Trait(
        ast::ItemTrait {
            vis,
            trait_token,
            ident,
            generics,
            super_traits,
            brace_open,
            items,
            brace_close
        }
    ),

    <vis:Visibility?> <trait_token:Trait> <ident:Ident> <generics:Generics?> <where_clause:WhereClause?> <eq:Eq> <bounds:PunctNoTrail<TypePath, Plus>> <semi:Semi> => ast::Item::TraitAlias(
        ast::ItemTraitAlias {
            vis,
            trait_token,
            ident,
            generics,
            eq,
            bounds,
            semi
        }
    ),

    /// https://doc.rust-lang.org/reference/items/implementations.html
    <impl_token:Impl> <generics:Generics?> <of:(TypePath For)?> <ty:Box<Type>> <where_clause:WhereClause?> <brace_open:BraceOpen> <items:ImplItem*> <brace_close:BraceClose> => ast::Item::Impl(
        ast::ItemImpl {
            impl_token,
            generics,
            of,
            ty,
            brace_open,
            items,
            brace_close
        }
    ),

    <vis:Visibility?> <entity:Entity> <ident:Ident> <generics:Generics?> <where_clause:WhereClause?> <brace_open:BraceOpen> <ports:Ports> <brace_close:BraceClose> => ast::Item::Entity(
        ast::ItemEntity {
            vis,
            entity,
            ident,
            generics,
            brace_open,
            ports,
            brace_close
        }
    ),
    <arch:Arch> <generics:Generics?> <entity:TypePath> <where_clause:WhereClause?> <brace_open:BraceOpen> <items:ArchItem*> <brace_close:BraceClose> => ast::Item::Arch(
        ast::ItemArch {
            arch,
            generics,
            entity,
            brace_open,
            items,
            brace_close
        }
    )
    // <vis:Visibility?> <bag:Bag> <ident:Ident> <brace_open:BraceOpen> <literals:PunctCanTrail<Lit, Comma>> <brace_close:BraceClose> => ast::Item::Bag(
    //     ast::ItemBag {
    //         vis,
    //         bag,
    //         brace_open,
    //         literals,
    //         brace_close
    //     }
    // ),
    // <vis:Visibility?> <ring:Ring> <ident:Ident> <eq:Eq> <range:RangeExpression> <semi:Semi> => ast::Item::Ring(
    //     ast::ItemRing {
    //         vis,
    //         ring,
    //         ident,
    //         eq,
    //         range,
    //         semi
    //     }
    // ),
};

/// https://doc.rust-lang.org/reference/items/use-declarations.html
UseTree: ast::UseTree = {
    UseLeaf,
    <path:UseTreePath> <tree:UseLeaf> => ast::UseTree::Path(
        ast::UseTreePath {
            path,
            tree: Box::new(tree)
        }
    ),
};

#[inline]
UseTreePath: ast::SimplePath = <leading_sep:PathSep?> <inner:(PathSegment PathSep)+> => ast::SimplePath { leading_sep, segments: ast::Punctuated { inner, last: None } };

UseLeaf: ast::UseTree = {
    Star => ast::UseTree::Glob(<>),
    <brace_open:BraceOpen> <trees:PunctCanTrail<UseTree, Comma>> <brace_close:BraceClose> => ast::UseTree::Group(
        ast::UseTreeGroup {
            brace_open,
            trees,
            brace_close
        }
    ),
    <name:PathSegment> <as_token:As> <rename:Ident> => ast::UseTree::Rename(
        ast::UseTreeRename {
            name,
            as_token,
            rename
        }
    ),
    PathSegment => ast::UseTree::Name(<>),
};

/// https://doc.rust-lang.org/reference/visibility-and-privacy.html
#[inline]
Visibility: ast::Vis = {
    Pub => ast::Vis::Pub(<>),
    Priv => ast::Vis::Priv(<>),
    <pub_token:Pub> <paren_open:ParenOpen> <in_token:In> <path:Path> <paren_close:ParenClose> => ast::Vis::Restricted(
        ast::VisRestricted {
            pub_token,
            paren_open,
            in_token,
            path,
            paren_close
        }
    ),
    <pub_token:Pub> <paren_open:ParenOpen> <crate_token:Crate> <paren_close:ParenClose> => ast::Vis::Crate(
        ast::VisCrate {
            pub_token,
            paren_open,
            crate_token,
            paren_close
        }
    ),
    <pub_token:Pub> <paren_open:ParenOpen> <super_token:Super> <paren_close:ParenClose> => ast::Vis::Super(
        ast::VisSuper {
            pub_token,
            paren_open,
            super_token,
            paren_close
        }
    ),
    <pub_token:Pub> <paren_open:ParenOpen> <self_token:LowerSelf> <paren_close:ParenClose> => ast::Vis::LowerSelf(
        ast::VisLowerSelf {
            pub_token,
            paren_open,
            self_token,
            paren_close
        }
    )
};

/// https://doc.rust-lang.org/reference/items/functions.html
#[inline]
Sig: ast::Sig = <ident:Ident> <generics:Generics?> <paren_open:ParenOpen> <inputs:FnArgs> <paren_close:ParenClose> <output:(RArrow Type)?> <where_clause:WhereClause?> => ast::Sig {
    ident,
    generics,
    paren_open,
    inputs,
    paren_close,
    output
};

FnArgs: ast::Punctuated<ast::FnArg, ast::token::Comma> = {
    <receiver:LowerSelf> => ast::Punctuated {
        inner: vec![],
        last: Some(Box::new(ast::FnArg::Receiver(receiver))),
    },
    <receiver:(LowerSelf Comma)> <mut args:PunctCanTrail<FnArg, Comma>> => {
        args.inner.insert(0, (ast::FnArg::Receiver(receiver.0), receiver.1));
        args
    },
    PunctCanTrail<FnArg, Comma>,
};
FnArg: ast::FnArg = PatType => ast::FnArg::Typed(<>);
PatType: ast::PatType = <pat:Pat> <colon:Colon> <ty:Type> => ast::PatType { pat, colon, ty };

/// https://doc.rust-lang.org/reference/items/generics.html
Generics: ast::Generics = <lt:Lt> <params:PunctCanTrail<GenericParam, Comma>> <gt:Gt> => ast::Generics { lt, params, gt };

/// https://doc.rust-lang.org/reference/items/generics.html#where-clauses
#[inline]
WhereClause: ast::WhereClause = <where_token:Where> <items:PunctCanTrail<WhereClauseItem, Comma>> => ast::WhereClause { where_token, items };
#[inline]
WhereClauseItem: ast::WhereClauseItem = {
    <ty:Type> <colon:Colon> <bounds:PunctNoTrail<TypePath, Plus>> => ast::WhereClauseItem::Type(ast::WhereClauseItemType { ty, colon, bounds })
};

GenericParam: ast::GenericParam = {
    <ident:Ident> <bounds:(Colon PunctNoTrail<TypePath, Plus>)?> <eq:(Eq Type)?> => ast::GenericParam::Type(
        ast::GenericParamType {
            ident,
            bounds,
            eq,
        }
    ),
    <const_token:Const> <ident:Ident> <colon:Colon> <ty:Type> <default:(Eq Bin3)?> => ast::GenericParam::Const(
        ast::GenericParamConst {
            const_token,
            ident,
            colon,
            ty,
            default
        }
    ),
};

/// https://doc.rust-lang.org/reference/items/structs.html
#[inline]
StructFields: (ast::Fields, Option<ast::token::Semi>, Option<ast::WhereClause>) = {
    <where_clause:WhereClause?> <brace_open:BraceOpen> <inner:PunctCanTrail<NamedField, Comma>> <brace_close:BraceClose> => (ast::Fields::Named(
        ast::FieldsNamed {
            brace_open,
            inner,
            brace_close
        }
    ), None, where_clause),
    <paren_open:ParenOpen> <inner:PunctCanTrail<UnnamedField, Comma>> <paren_close:ParenClose> <where_clause:WhereClause?> <semi:Semi> => (ast::Fields::Unnamed(
        ast::FieldsUnnamed {
            paren_open,
            inner,
            paren_close
        }
    ), Some(semi), where_clause)
};
NamedField: ast::NamedField = <vis:Visibility?> <ident:Ident> <colon:Colon> <ty:Type> => ast::NamedField { vis, ident, colon, ty };
UnnamedField: ast::UnnamedField = <vis:Visibility?> <ty:Type> => ast::UnnamedField { vis, ty };

/// https://doc.rust-lang.org/reference/items/enumerations.html
Variant: ast::Variant = {
    <ident:Ident> <fields:EnumFields> => ast::Variant { ident, variant_type: ast::VariantType::Fields(fields), },
    <ident:Ident> => ast::Variant { ident, variant_type: ast::VariantType::Unit(()), },
    <ident:Ident> <eq:Eq> <expr:Expr> => ast::Variant { ident: ident, variant_type: ast::VariantType::Discrim(ast::VariantTypeDiscrim { eq, expr }), },
};

EnumFields: ast::Fields = {
    <brace_open:BraceOpen> <inner:PunctCanTrail<NamedField, Comma>> <brace_close:BraceClose> => ast::Fields::Named(
        ast::FieldsNamed {
            brace_open,
            inner,
            brace_close
        }
    ),
    <paren_open:ParenOpen> <inner:PunctCanTrail<UnnamedField, Comma>> <paren_close:ParenClose> => ast::Fields::Unnamed(
        ast::FieldsUnnamed {
            paren_open,
            inner,
            paren_close
        }
    ),
};

// https://doc.rust-lang.org/reference/items/traits.html
TraitItem: ast::TraitItem = {
    <vis:Visibility?> <const_token:Const> <ident:Ident> <colon:Colon> <ty:Type> <default:(Eq Expr)?> <semi:Semi> => ast::TraitItem::Const(
        ast::TraitItemConst {
            vis,
            const_token,
            ident,
            colon,
            ty,
            default,
            semi
        }
    ),
    <vis:Visibility?> <fn_token:Fn> <sig:Sig> <block:Block> => ast::TraitItem::Fn(
        ast::TraitItemFn {
            vis,
            fn_token,
            sig,
            block: Some(block),
            semi: None,
        }
    ),
    <vis:Visibility?> <fn_token:Fn> <sig:Sig> <semi:Semi> => ast::TraitItem::Fn(
        ast::TraitItemFn {
            vis,
            fn_token,
            sig,
            block: None,
            semi: Some(semi),
        }
    ),
    <vis:Visibility?> <type_token:TokenType> <ident:Ident> <bounds:(Colon PunctNoTrail<TypePath, Plus>)?> <default:(Eq Type)?> <semi:Semi> => ast::TraitItem::Type(
        ast::TraitItemType {
            vis,
            type_token,
            ident,
            bounds,
            default,
            semi
        }
    )
};

/// https://doc.rust-lang.org/reference/items/implementations.html
ImplItem: ast::ImplItem = {
    ItemConst => ast::ImplItem::Const(<>),
    ItemFn => ast::ImplItem::Fn(<>),
    ItemType => ast::ImplItem::Type(<>),
};

Ports: ast::Punctuated<ast::Port, ast::token::Comma> = PunctCanTrail<Port, Comma>;
#[inline]
PortType: ast::PortType = {
    In => ast::PortType::In(<>),
    Out => ast::PortType::Out(<>),
    InOut => ast::PortType::InOut(<>)
};
Port: ast::Port = <port_type:PortType> <ident:Ident> <colon: Colon> <ty:Type> <expr:(Eq Expr)?> => ast::Port {
    port_type,
    ident,
    colon,
    ty,
    expr
};

ArchItem: ast::ArchItem = {
    ItemConst => ast::ArchItem::Const(<>),
    Local => ast::ArchItem::Let(<>),
    <when:When> <expr:ExprIf> <block:Block> => ast::ArchItem::When(
        ast::ArchItemWhen {
            when,
            expr,
            block
        }
    ),
    <path:PathInExpression> <brace_open:BraceOpen> <fields:PunctCanTrail<EntityFieldValue, Comma>> <brace_close:BraceClose> => ast::ArchItem::EntityExpression(
        ast::ArchItemEntityExpression {
            path,
            brace_open,
            fields,
            brace_close
        }
    )
};
#[inline]
EntityFieldValue: ast::EntityFieldValue = <ident:Ident> <expr:(Colon Expr)?> => ast::EntityFieldValue { ident, expr };

/// https://doc.rust-lang.org/reference/expressions/literal-expr.html
LiteralExpression: ast::Expr = Lit => ast::Expr::Lit(<>);
/// https://doc.rust-lang.org/reference/expressions/path-expr.html
// TODO: support self qualifiers
PathInExpression: ast::ExprPath = {
    <leading_sep:PathSep?> <inner:(PathInExpressionSegment PathSep)+> <last:Box<PathInExpressionSegmentLast>> => {
        ast::ExprPath {
            leading_sep,
            segments: ast::Punctuated {
                inner,
                last: Some(last)
            }
        }
    },
    <leading_sep:PathSep?> <last:Box<PathInExpressionSegmentLast>> => {
        ast::ExprPath {
            leading_sep,
            segments: ast::Punctuated {
                inner: vec![],
                last: Some(last)
            }
        }
    }
};

#[inline]
PathInExpressionSegment: ast::PathSegment = {
    <ident:PathSegment> => ast::PathSegment {
        ident,
        generic_args: None
    },
    <ident:PathSegment> <path_sep:PathSep> <lt:Lt> <args:PunctCanTrail<GenericArg, Comma>> <gt:Gt> => ast::PathSegment {
        ident,
        generic_args: Some(ast::GenericArgs {
            path_sep: Some(path_sep),
            lt,
            args,
            gt
        })
    }
};

#[inline]
PathInExpressionSegmentLast: ast::PathSegment = {
    <ident:Ident> => ast::PathSegment { ident, generic_args: None },
    <left:@L> <upper_self:UpperSelf> <right:@R> => ast::PathSegment { ident: ast::token::Ident { inner: upper_self.to_string(), span: ast::token::Span(left, right) }, generic_args: None },
    <ident:Ident> <path_sep:PathSep> <lt:Lt> <args:PunctCanTrail<GenericArg, Comma>> <gt:Gt> => ast::PathSegment {
        ident,
        generic_args: Some(ast::GenericArgs {
            path_sep: Some(path_sep),
            lt,
            args,
            gt
        })
    }
};

GenericArg: ast::GenericArg = {
    Type => ast::GenericArg::Type(<>),
    BlockExpression => ast::GenericArg::Expr(<>),
    LiteralExpression => ast::GenericArg::Expr(<>),
    <ident: Ident> <eq: Eq> <ty: Type> => ast::GenericArg::Binding(ast::GenericArgBinding { ident, eq, ty })
};

/// https://doc.rust-lang.org/reference/expressions/block-expr.html
BlockExpression: ast::Expr = Block => ast::Expr::Block(<>);
Block: ast::Block = <brace_open:BraceOpen> <statements:Statements?> <brace_close:BraceClose> => ast::Block {
    brace_open,
    statements: statements.unwrap_or_default(),
    brace_close
};

/// https://doc.rust-lang.org/reference/statements.html#let-statements
Local: ast::StmtLocal = <let_token:Let> <pat:Pat> <ty:(Colon Type)?> <init:(Eq Box<Expr>)?> <semi:Semi> => ast::StmtLocal {
    let_token,
    pat,
    ty,
    init,
    semi
};

/// https://doc.rust-lang.org/reference/statements.html
Statement: ast::Stmt = {
    /// https://doc.rust-lang.org/reference/statements.html#item-declarations
    Item => ast::Stmt::Item(<>),
    /// https://doc.rust-lang.org/reference/statements.html#let-statements
    Local => ast::Stmt::Local(<>),

    /// https://doc.rust-lang.org/reference/statements.html#expression-statements
    <expr:ExprStmt> <semi:Semi> => ast::Stmt::Expr (
        ast::StmtExpr {
            expr,
            semi: Some(semi)
        }
    ),
    <expr:ExprWithBlock> <semi:Semi?> => ast::Stmt::Expr (
        ast::StmtExpr {
            expr,
            semi,
        }
    )
};

/// https://doc.rust-lang.org/reference/expressions/block-expr.html
Statements: Vec<ast::Stmt> = {
    <Statement+>,
    <mut v:Statement+> <expr:ExprStmt> => {
        v.push(ast::Stmt::Expr (ast::StmtExpr { expr, semi: None }));
        v
    },
    <expr:ExprStmt> => vec![ast::Stmt::Expr(ast::StmtExpr { expr, semi: None })]
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#negation-operators
Unary: ast::Expr = {
    <minus:Minus> <expr:ExprWithoutBlockOrOperator> => ast::Expr::Unary(
        ast::ExprUnary {
            op: ast::UnOp::Minus(minus),
            expr: Box::new(expr)
        }
    ),
    <minus:Minus> <expr:ExprWithBlock> => ast::Expr::Unary(
        ast::ExprUnary {
            op: ast::UnOp::Minus(minus),
            expr: Box::new(expr)
        }
    ),

    <not:Not> <expr:ExprWithoutBlockOrOperator> => ast::Expr::Unary(
        ast::ExprUnary {
            op: ast::UnOp::Not(not),
            expr: Box::new(expr)
        }
    ),
    <not:Not> <expr:ExprWithBlock> => ast::Expr::Unary(
        ast::ExprUnary {
            op: ast::UnOp::Not(not),
            expr: Box::new(expr)
        }
    ),

    ExprWithoutBlockOrOperator,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions
Cast: ast::Expr = {
    <expr:Unary> <as_token:As> <ident:Ident> => ast::Expr::Cast(
        ast::ExprCast {
            expr: Box::new(expr),
            as_token,
            ty: Box::new(ast::Type::Path(ast::TypePath { leading_sep: None, segments: ast::Punctuated { inner: vec![], last: Some(Box::new(ast::PathSegment { ident, generic_args: None }))}}))
        }
    ),
    <expr:ExprWithBlock> <as_token:As> <ident:Ident> => ast::Expr::Cast(
        ast::ExprCast {
            expr: Box::new(expr),
            as_token,
            ty: Box::new(ast::Type::Path(ast::TypePath { leading_sep: None, segments: ast::Punctuated { inner: vec![], last: Some(Box::new(ast::PathSegment { ident, generic_args: None }))}}))
        }
    ),

    Unary,
};

Arith0: ast::Expr = {
    <l:Arith0> <op:StarStar> <r:Cast> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::StarStar(op),
            right: Box::new(r)
        }
    ),
    <l:Arith0> <op:StarStar> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::StarStar(op),
            right: Box::new(r)
        }
    ),

    Cast,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators
Arith1: ast::Expr = {
    <l:Arith1> <op:Slash> <r:Arith0> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Slash(op),
            right: Box::new(r)
        }
    ),
    <l:Arith1> <op:Slash> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Slash(op),
            right: Box::new(r)
        }
    ),

    <l:Arith1> <op:Percent> <r:Arith0> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Percent(op),
            right: Box::new(r)
        }
    ),
    <l:Arith1> <op:Percent> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Percent(op),
            right: Box::new(r)
        }
    ),

    <l:Arith1> <op:Star> <r:Arith0> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Star(op),
            right: Box::new(r)
        }
    ),
    <l:Arith1> <op:Star> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Star(op),
            right: Box::new(r)
        }
    ),

    Arith0,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators
Arith2: ast::Expr = {
    <l:Arith2> <op:Plus> <r:Arith1> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Plus(op),
            right: Box::new(r)
        }
    ),
    <l:Arith2> <op:Plus> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Plus(op),
            right: Box::new(r)
        }
    ),

    <l:Arith2> <op:Minus> <r:Arith1> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Minus(op),
            right: Box::new(r)
        }
    ),
    <l:Arith2> <op:Minus> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Minus(op),
            right: Box::new(r)
        }
    ),

    Arith1,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators
Bin0: ast::Expr = {
    <l:Bin0> <op:Shr> <r:Arith2> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Shr(op),
            right: Box::new(r)
        }
    ),
    <l:Bin0> <op:Shr> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Shr(op),
            right: Box::new(r)
        }
    ),

    <l:Bin0> <op:Shl> <r:Arith2> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Shl(op),
            right: Box::new(r)
        }
    ),
    <l:Bin0> <op:Shl> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Shl(op),
            right: Box::new(r)
        }
    ),

    Arith2,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators
Bin1: ast::Expr = {
    <l:Bin1> <op:And> <r:Bin0> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::And(op),
            right: Box::new(r)
        }
    ),
    <l:Bin1> <op:And> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::And(op),
            right: Box::new(r)
        }
    ),

    Bin0,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators
Bin2: ast::Expr = {
    <l:Bin2> <op:Caret> <r:Bin1> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Caret(op),
            right: Box::new(r)
        }
    ),
    <l:Bin2> <op:Caret> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Caret(op),
            right: Box::new(r)
        }
    ),

    Bin1,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators
Bin3: ast::Expr = {
    <l:Bin3> <op:Or> <r:Bin2> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Or(op),
            right: Box::new(r)
        }
    ),
    <l:Bin3> <op:Or> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Or(op),
            right: Box::new(r)
        }
    ),

    Bin2,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#comparison-operators
ComparisonExpression: ast::Expr = {
    <l:Bin3> <op:EqEq> <r:Bin3> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::EqEq(op),
            right: Box::new(r)
        }
    ),
    <l:Bin3> <op:EqEq> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::EqEq(op),
            right: Box::new(r)
        }
    ),

    <l:Bin3> <op:Ne> <r:Bin3> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Ne(op),
            right: Box::new(r)
        }
    ),
    <l:Bin3> <op:Ne> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Ne(op),
            right: Box::new(r)
        }
    ),

    <l:Bin3> <op:Lt> <r:Bin3> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Lt(op),
            right: Box::new(r)
        }
    ),
    <l:Bin3> <op:Lt> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Lt(op),
            right: Box::new(r)
        }
    ),

    <l:Bin3> <op:Le> <r:Bin3> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Le(op),
            right: Box::new(r)
        }
    ),
    <l:Bin3> <op:Le> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Le(op),
            right: Box::new(r)
        }
    ),

    <l:Bin3> <op:Gt> <r:Bin3> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Gt(op),
            right: Box::new(r)
        }
    ),
    <l:Bin3> <op:Gt> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Gt(op),
            right: Box::new(r)
        }
    ),

    <l:Bin3> <op:Ge> <r:Bin3> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Ge(op),
            right: Box::new(r)
        }
    ),
    <l:Bin3> <op:Ge> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Ge(op),
            right: Box::new(r)
        }
    ),
    Bin3,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#assignment-expressions
/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#compound-assignment-expressions
AssignExpression: ast::Expr = {
    <l:ComparisonExpression> <op:Eq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::Eq(op),
            rhs: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:Eq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::Eq(op),
            rhs: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:PlusEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::PlusEq(op),
            rhs: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:PlusEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::PlusEq(op),
            rhs: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:MinusEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::MinusEq(op),
            rhs: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:MinusEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::MinusEq(op),
            rhs: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:StarEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::StarEq(op),
            rhs: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:StarEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::StarEq(op),
            rhs: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:StarStarEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::StarStarEq(op),
            rhs: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:StarStarEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::StarStarEq(op),
            rhs: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:SlashEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::SlashEq(op),
            rhs: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:SlashEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::SlashEq(op),
            rhs: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:PercentEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::PercentEq(op),
            rhs: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:PercentEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::PercentEq(op),
            rhs: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:AndEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::AndEq(op),
            rhs: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:AndEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::AndEq(op),
            rhs: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:OrEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::OrEq(op),
            rhs: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:OrEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::OrEq(op),
            rhs: Box::new(r)
        }
    ),
    
    <l:ComparisonExpression> <op:CaretEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::CaretEq(op),
            rhs: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:CaretEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::CaretEq(op),
            rhs: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:ShlEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::ShlEq(op),
            rhs: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:ShlEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::ShlEq(op),
            rhs: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:ShrEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::ShrEq(op),
            rhs: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:ShrEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            lhs: Box::new(l),
            op: ast::AssOp::ShrEq(op),
            rhs: Box::new(r)
        }
    ),

    ComparisonExpression,
};

/// https://doc.rust-lang.org/reference/expressions/grouped-expr.html
GroupedExpression: ast::Expr = <paren_open:ParenOpen> <expr:Expr> <paren_close:ParenClose> => ast::Expr::Grouped(
    ast::ExprGrouped {
        paren_open,
        expr: Box::new(expr),
        paren_close
    }
);

/// https://doc.rust-lang.org/reference/expressions/array-expr.html#array-expressions
ArrayExpression: ast::Expr = {
    <bracket_open:BracketOpen> <init:Box<Expr>> <semi:Semi> <repeat:Box<Expr>> <bracket_close:BracketClose> => ast::Expr::Repeat(
        ast::ExprRepeat {
            bracket_open,
            init,
            semi,
            repeat,
            bracket_close
        }
    ),
    <bracket_open:BracketOpen> <elements:PunctCanTrail<Expr, Comma>> <bracket_close:BracketClose> => ast::Expr::Array(
        ast::ExprArray {
            bracket_open,
            elements,
            bracket_close
        }
    ),
};

/// https://doc.rust-lang.org/reference/expressions/array-expr.html#array-and-slice-indexing-expressions
IndexExpression: ast::Expr = <on:ExprWithoutBlockOrOperator> <bracket_open:BracketOpen> <index:Expr> <bracket_close:BracketClose> => ast::Expr::Index(
    ast::ExprIndex {
        on: Box::new(on),
        bracket_open,
        index: Box::new(index),
        bracket_close
    }
);

/// https://doc.rust-lang.org/reference/expressions/tuple-expr.html#tuple-expressions
TupleExpression: ast::Expr = <paren_open:ParenOpen> <elements:TupleElements> <paren_close:ParenClose> => ast::Expr::Tuple(
    ast::ExprTuple {
        paren_open,
        elements,
        paren_close
    }
);
TupleElements: ast::Punctuated<ast::Expr, ast::token::Comma> = <inner:(Expr Comma)+> <last:Box<Expr>?> => {
    ast::Punctuated {
        inner,
        last
    }
};

/// https://doc.rust-lang.org/reference/expressions/tuple-expr.html#tuple-indexing-expressions
TupleIndexingExpression: ast::Expr = {
    <on:Box<ExprWithBlock>> <dot:Dot> <unnamed:PlainLitInt> => ast::Expr::Field(
        ast::ExprField {
            on,
            dot,
            member: ast::Member::Unnamed(unnamed)
        }
    ),
    <on:Box<ExprWithoutBlockOrOperator>> <dot:Dot> <unnamed:PlainLitInt> => ast::Expr::Field(
        ast::ExprField {
            on,
            dot,
            member: ast::Member::Unnamed(unnamed)
        }
    )
};

/// https://doc.rust-lang.org/reference/expressions/struct-expr.html#struct-expressions
StructExpression: ast::Expr = {
    <path:PathInExpression> <brace_open:BraceOpen> <fields:PunctMustTrail<FieldValue, Comma>> <base:(DotDot Box<Expr>)> <comma:Comma?> <brace_close:BraceClose> => ast::Expr::Struct(
        ast::ExprStruct {
            path,
            brace_open,
            fields,
            base: Some(base),
            comma,
            brace_close
        }
    ),
    <path:PathInExpression> <brace_open:BraceOpen> <fields:PunctCanTrail<FieldValue, Comma>> <brace_close:BraceClose> => ast::Expr::Struct(
        ast::ExprStruct {
            path,
            brace_open,
            fields,
            base: None,
            comma: None,
            brace_close
        }
    ),
};

FieldValue: ast::FieldValue = {
    <named:Ident> <expr:(Colon Expr)?> => ast::FieldValue { member: ast::Member::Named(named), expr },
    <unnamed:PlainLitInt> <expr:(Colon Expr)> => ast::FieldValue { member: ast::Member::Unnamed(unnamed), expr: Some(expr) },
};

/// https://doc.rust-lang.org/reference/expressions/call-expr.html
CallExpression: ast::Expr = <on:Box<ExprWithoutFieldOrBlock>> <paren_open:ParenOpen> <args:PunctCanTrail<Expr, Comma>> <paren_close:ParenClose> => ast::Expr::Call(
    ast::ExprCall {
        on,
        paren_open,
        args,
        paren_close
    }
);

/// https://doc.rust-lang.org/reference/expressions/method-call-expr.html
MethodCallExpression: ast::Expr = {
    <on:Box<ExprWithBlock>> <dot:Dot> <method:Ident> <paren_open:ParenOpen> <args:PunctCanTrail<Expr, Comma>> <paren_close:ParenClose> => ast::Expr::MethodCall(
        ast::ExprMethodCall {
            on,
            dot,
            method,
            paren_open,
            args,
            paren_close
        }    
    ),
    <on:Box<ExprWithoutBlockOrOperator>> <dot:Dot> <method:Ident> <paren_open:ParenOpen> <args:PunctCanTrail<Expr, Comma>> <paren_close:ParenClose> => ast::Expr::MethodCall(
        ast::ExprMethodCall {
            on,
            dot,
            method,
            paren_open,
            args,
            paren_close
        }
    )
};

/// https://doc.rust-lang.org/reference/expressions/field-expr.html
FieldExpression: ast::Expr = {
    <on:Box<ExprWithBlock>> <dot:Dot> <named:Ident> => ast::Expr::Field(
        ast::ExprField {
            on,
            dot,
            member: ast::Member::Named(named)
        }
    ),
    <on:Box<ExprWithoutBlockOrOperator>> <dot:Dot> <named:Ident> => ast::Expr::Field(
        ast::ExprField {
            on,
            dot,
            member: ast::Member::Named(named)
        }
    )
};

// todo: closure expression

IteratorLoopExpression: ast::Expr = {
    <for_token:For> <pat:Box<Pat>> <in_token:In> <expr:Box<ExprIf>> <block:Block> => ast::Expr::For(
        ast::ExprFor {
            for_token,
            pat,
            in_token,
            expr,
            block
        }
    )
};

/// https://doc.rust-lang.org/reference/expressions/range-expr.html
RangeExpression: ast::Expr = {
    <left:Box<LiteralExpression>?> <dotdot:DotDot> <right:Box<LiteralExpression>?> => ast::Expr::Range(
        ast::ExprRange {
            left,
            range_type: ast::RangeType::HalfOpen(dotdot),
            right
        }
    ),
    <left:Box<LiteralExpression>?> <dotdoteq:DotDotEq> <right:Box<LiteralExpression>?> => ast::Expr::Range(
        ast::ExprRange {
            left,
            range_type: ast::RangeType::Closed(dotdoteq),
            right
        }
    )
};

// todo: if let expression
/// https://doc.rust-lang.org/reference/expressions/if-expr.html
IfExpression: ast::Expr = {
    <if_token:If> <expr:Box<ExprIf>> <block:Block> <else_token:(Else Box<IfExpression>)?> => ast::Expr::If(
        ast::ExprIf {
            if_token,
            expr,
            block,
            else_token
        }
    ),
    <if_token:If> <expr:Box<ExprIf>> <block:Block> <else_token:(Else Box<BlockExpression>)> => ast::Expr::If(
        ast::ExprIf {
            if_token,
            expr,
            block,
            else_token: Some(else_token)
        }
    )
};

/// https://doc.rust-lang.org/reference/expressions/match-expr.html
MatchExpression: ast::Expr = <match_token:Match> <expr:Box<ExprIf>> <brace_open:BraceOpen> <arms:PunctCanTrail<MatchArm, Comma>> <brace_close:BraceClose> => ast::Expr::Match(
    ast::ExprMatch {
        match_token,
        expr,
        brace_open,
        arms,
        brace_close
    }
);

MatchArm: ast::Arm = {
    <pat:Pat> <guard:(If ExprIf)?> <fat_arrow:FatArrow> <body:Expr> => ast::Arm {
        pat,
        guard,
        fat_arrow,
        body
    },
};

/// https://doc.rust-lang.org/reference/expressions/return-expr.html
ReturnExpression: ast::Expr = <return_token:Return> <expr:Box<Expr>?> => ast::Expr::Return(
    ast::ExprReturn {
        return_token,
        expr
    }
);

ExprWithoutFieldOrBlock: ast::Expr = {
    LiteralExpression,
    PathInExpression => ast::Expr::Path(<>),
    <left:@L> <lower_self:LowerSelf> <right:@R> => ast::Expr::Path(ast::ExprPath { leading_sep: None, segments: ast::Punctuated { inner: vec![], last: Some(Box::new(ast::PathSegment { ident: ast::token::Ident { inner: lower_self.to_string(), span: ast::token::Span(left, right) }, generic_args: None })) }}),
    GroupedExpression,
    ArrayExpression,
    IndexExpression,
    TupleExpression,
    TupleIndexingExpression,
    CallExpression,
    MethodCallExpression,
    RangeExpression,
};

ExprWithoutBlockOrOperator: ast::Expr = {
    ExprWithoutFieldOrBlock,
    FieldExpression,
};

ExprStmt: ast::Expr = {
    AssignExpression,
    ReturnExpression,
};

/// https://doc.rust-lang.org/reference/expressions.html
ExprWithBlock: ast::Expr = {
    BlockExpression,
    IfExpression,
    MatchExpression,
    IteratorLoopExpression,
    // StructExpression,
};

ExprIf: ast::Expr = {
    ComparisonExpression,
    ExprWithBlock,
};

/// https://doc.rust-lang.org/reference/expressions.html
pub Expr: ast::Expr = {
    ComparisonExpression,
    ExprWithBlock,
    // TODO: add struct expression to arithmetic tree in a way that it won't conflict with if/match statements
    StructExpression,
};

/// https://doc.rust-lang.org/reference/patterns.html
pub Pat: ast::Pat = {
    /// https://doc.rust-lang.org/reference/patterns.html#literal-patterns
    Lit => ast::Pat::Lit(<>),
    /// https://doc.rust-lang.org/reference/patterns.html#identifier-patterns and https://doc.rust-lang.org/reference/patterns.html#path-patterns
    PathInExpression => {
        if <>.leading_sep.is_none() && <>.segments.inner.is_empty() {
            if let Some(segment) = <>.segments.last.as_ref() {
                if segment.generic_args.is_none() {
                    ast::Pat::Ident(segment.ident.clone())
                } else {
                    ast::Pat::Path(<>)
                }
            } else {
                ast::Pat::Path(<>)
            }
        } else {
            ast::Pat::Path(<>)
        }
    },
    /// https://doc.rust-lang.org/reference/patterns.html#wildcard-pattern
    Underscore => ast::Pat::Wildcard(<>),
    /// https://doc.rust-lang.org/reference/patterns.html#range-patterns
    <left:RangePatternBound> <dotdot:DotDot> <right:RangePatternBound> => ast::Pat::Range(
        ast::PatRange {
            left,
            range_type: ast::RangeType::HalfOpen(dotdot),
            right
        }
    ),
    <left:RangePatternBound> <dotdoteq:DotDotEq> <right:RangePatternBound> => ast::Pat::Range(
        ast::PatRange {
            left,
            range_type: ast::RangeType::Closed(dotdoteq),
            right
        }
    ),
    /// https://doc.rust-lang.org/reference/patterns.html#struct-patterns
    <path:PathInExpression> <brace_open:BraceOpen> <elems:StructPatternElements> <brace_close:BraceClose> => ast::Pat::Struct(
        ast::PatStruct {
            path,
            brace_open,
            fields: elems.0,
            remaining: elems.1,
            brace_close
        }
    ),
    /// https://doc.rust-lang.org/reference/patterns.html#tuple-struct-patterns
    <path:PathInExpression> <paren_open:ParenOpen> <subpats:PunctNoTrail<Pat, Comma>> <paren_close:ParenClose> => ast::Pat::TupleStruct(
        ast::PatTupleStruct {
            path,
            paren_open,
            subpats,
            rest_subpats: None,
            paren_close
        }
    ),
    <path:PathInExpression> <paren_open:ParenOpen> <subpats:PunctMustTrail<Pat, Comma>> <rest_subpats:(DotDot Comma PunctCanTrail<Pat, Comma>)?> <paren_close:ParenClose> => ast::Pat::TupleStruct(
        ast::PatTupleStruct {
            path,
            paren_open,
            subpats,
            rest_subpats,
            paren_close
        }
    ),
    /// https://doc.rust-lang.org/reference/patterns.html#tuple-patterns and https://doc.rust-lang.org/reference/patterns.html#grouped-patterns
    <paren_open:ParenOpen> <subpats:PunctNoTrail<Pat, Comma>> <paren_close:ParenClose> => ast::Pat::Tuple(
        ast::PatTuple {
            paren_open,
            subpats,
            rest_subpats: None,
            paren_close
        }
    ),
    <paren_open:ParenOpen> <subpats:PunctMustTrail<Pat, Comma>> <rest_subpats:(DotDot Comma PunctCanTrail<Pat, Comma>)?> <paren_close:ParenClose> => ast::Pat::Tuple(
        ast::PatTuple {
            paren_open,
            subpats,
            rest_subpats,
            paren_close
        }
    ),
    /// https://doc.rust-lang.org/reference/patterns.html#slice-patterns
    <bracket_open:BracketOpen> <subpats:PunctCanTrail<Pat, Comma>> <bracket_close:BracketClose> => ast::Pat::Slice(
        ast::PatSlice {
            bracket_open,
            subpats,
            bracket_close
        }
    ),
};

RangePatternBound: ast::Expr = {
    LiteralExpression,
    // GroupedExpression,
    PathInExpression => ast::Expr::Path(<>),
};

StructPatternElements: (ast::Punctuated<ast::StructPatternField, ast::token::Comma>, Option<ast::token::DotDot>) = {
    PunctCanTrail<StructPatternField, Comma> => (<>, None),
    <fields:PunctMustTrail<StructPatternField, Comma>> <dotdot:DotDot> => (fields, Some(dotdot)),
};

StructPatternField: ast::StructPatternField = {
    <index:PlainLitInt> <colon:Colon> <pat:Box<Pat>> => ast::StructPatternField::TuplePat(
        ast::StructPatternFieldTuplePat {
            index,
            colon,
            pat
        }
    ),
    <ident:Ident> <colon:Colon> <pat:Box<Pat>> => ast::StructPatternField::IdentPat(
        ast::StructPatternFieldIdentPat {
            ident,
            colon,
            pat
        }
    ),
    Ident => ast::StructPatternField::Ident(<>),
};

/// https://doc.rust-lang.org/reference/types.html
pub Type: ast::Type = {
    /// https://doc.rust-lang.org/reference/paths.html#paths-in-types
    TypePath => ast::Type::Path(<>),

    /// https://doc.rust-lang.org/reference/types.html#parenthesized-types
    /// https://doc.rust-lang.org/reference/types/tuple.html#tuple-types
    <paren_open:ParenOpen> <tys: PunctCanTrail<Type, Comma>> <paren_close:ParenClose> => {
        if tys.inner.is_empty() && tys.last.is_some() {
            ast::Type::Parenthesized(
                ast::TypeParenthesized {
                    paren_open,
                    inner: tys.last.unwrap(),
                    paren_close
                }
            )
        } else {
            ast::Type::Tuple(
                ast::TypeTuple {
                    paren_open,
                    tys,
                    paren_close
                }
            )
        }
    },

    /// https://doc.rust-lang.org/reference/types/array.html
    <bracket_open:BracketOpen> <ty:Box<Type>> <semi:Semi> <lit:PlainLitInt> <bracket_close:BracketClose> => ast::Type::Array(
        ast::TypeArray {
            bracket_open,
            ty,
            semi,
            lit,
            bracket_close
        }
    ),

    /// https://doc.rust-lang.org/reference/types/slice.html
    <bracket_open:BracketOpen> <ty:Box<Type>> <bracket_close:BracketClose> => ast::Type::Slice(
        ast::TypeSlice {
            bracket_open,
            ty,
            bracket_close
        }
    ),

    /// https://doc.rust-lang.org/reference/types/inferred.html
    Underscore => ast::Type::Infer(<>),

    /// https://doc.rust-lang.org/reference/types/function-pointer.html
    /// TODO: support named params "MaybeNamedParam"
    <fn_token:Fn> <paren_open:ParenOpen> <args:PunctCanTrail<Type, Comma>> <paren_close:ParenClose> <ret:(RArrow Box<Type>)?> => ast::Type::Fn(
        ast::TypeFn {
            fn_token,
            paren_open,
            args,
            paren_close,
            ret
        }
    ),
};

TypePath: ast::TypePath = {
    // <leading_sep:PathSep?> <inner:(TypePathSegment PathSep)+> <last:Box<TypePathSegmentLast>> => {
    //     ast::TypePath {
    //         leading_sep,
    //         segments: ast::Punctuated {
    //             inner,
    //             last: Some(last)
    //         }
    //     }
    // },
    <leading_sep:PathSep?> <last:Box<TypePathSegmentLast>> => {
        ast::TypePath {
            leading_sep,
            segments: ast::Punctuated {
                inner: vec![],
                last: Some(last)
            }
        }
    },
    PathInExpression => ast::TypePath {
        leading_sep: <>.leading_sep,
        segments: <>.segments
    },
};

// TODO: allow a pathsep here, but unfortunately that makes it ambiguous with expr path segment
// TODO: allow fn args, which I couldn't get to work
#[inline]
TypePathSegment: ast::PathSegment = {
    PathInExpressionSegment => <>,
    <ident:PathSegment> <generic_args:TypePathSegmentGenericArgs> => ast::PathSegment {
        ident,
        generic_args: Some(generic_args)
    }
};

#[inline]
TypePathSegmentLast: ast::PathSegment = {
    <ident:Ident> <generic_args:TypePathSegmentGenericArgs> => ast::PathSegment {
        ident,
        generic_args: Some(generic_args)
    }
};

TypePathSegmentGenericArgs: ast::GenericArgs = <lt:Lt> <args:PunctCanTrail<GenericArg, Comma>> <gt:Gt> => ast::GenericArgs {
    path_sep: None,
    lt,
    args,
    gt
};
