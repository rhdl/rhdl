use rug::{Integer as Int, Float};

use std::str::FromStr;

use crate::ast;

grammar;

/// https://doc.rust-lang.org/reference/tokens.html
match {
    "if" => If,
    "else" => Else,
    "as" => As,
    "match" => Match,
    "let" => Let,
    "return" => Return,
    "fn" => Fn,
    "mut" => Mut,
    "in" => In,
    "pub" => Pub,
    "mod" => Mod,
    "struct" => Struct,
    "entity" => Entity,
    "enum" => Enum,
    "const" => Const,
    "impl" => Impl,
    "bag" => Bag,
    "ring" => Ring,
    "crate" => Crate,
    "super" => Super,
    "self" => LowerSelf,
    "Self" => UpperSelf,
    "type" => TokenType,
    "use" => Use,
    "macro" => Macro,
    "for" => For,
    "+" => Plus,
    "-" => Minus,
    "*" => Star,
    "**" => StarStar,
    "/" => Slash,
    "%" => Percent,
    "^" => Caret,
    "!" => Not,
    "&" => And,
    "|" => Or,
    "&&" => AndAnd,
    "||" => OrOr,
    "<<" => Shl,
    ">>" => Shr,
    "+=" => PlusEq,
    "-=" => MinusEq,
    "*=" => StarEq,
    "**=" => StarStarEq,
    "/=" => SlashEq,
    "%=" => PercentEq,
    "^=" => CaretEq,
    "&=" => AndEq,
    "|=" => OrEq,
    "<<=" => ShlEq,
    ">>=" => ShrEq,
    "=" => Eq,
    "==" => EqEq,
    "!=" => Ne,
    ">" => Gt,
    "<" => Lt,
    ">=" => Ge,
    "<=" => Le,
    "@" => At,
    "_" => Underscore,
    "." => Dot,
    ".." => DotDot,
    "..=" => DotDotEq,
    "," => Comma,
    ";" => Semi,
    ":" => Colon,
    "::" => PathSep,
    "->" => RArrow,
    "=>" => FatArrow,
    "#" => Pound,
    "$" => Dollar,
    "?" => Question,
    "[" => BracketOpen,
    "]" => BracketClose,
    "(" => ParenOpen,
    ")" => ParenClose,
    "{" => BraceOpen,
    "}" => BraceClose,
    "(break|continue|extern|false|loop|move|mut|ref|static|trait|true|unsafe|where|while|async|await|dyn|abstract|become|box|do|final|override|priv|typeof|unsized|virtual|yield|try|union)" => Keyword,
    "block" => BlockTok,
    "expr" => ExprTok,
    "ident" => IdentTok,
    "item" => ItemTok,
    "literal" => LitTok,
    "meta" => MetaTok,
    "pat" => PatTok,
    "path" => PathTok,
    "stmt" => StmtTok,
    "tt" => TokenTreeTok,
    "ty" => TypeTok,
    "vis" => VisTok,
    "r#crate" => RawCrate,
    "r#self" => RawLowerSelf,
    "r#Self" => RawUpperSelf,
    "r#super" => RawSuper,
} else {
    r"(?:[a-zA-Z][a-zA-Z0-9_]*|_[a-zA-Z0-9_]+)" => NonKeywordIdentifier,
    r"r#(?:[a-zA-Z][a-zA-Z0-9_]*|_[a-zA-Z0-9_]+)" => RawIdentifier,
    r"(0|[1-9]\d*(?:_\d+)*)" => Integer,
    r"0d\d+(?:_\d+)*" => DecimalInteger,
    r"0x[0-9a-fA-F]+(?:_[0-9a-fA-F]+)*" => HexInteger,
    r"0o[0-7]+(?:_[0-7]+)*" => OctalInteger,
    r"0b[01]+(?:_[01]+)*" => BinaryInteger,
    r"(?:2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36)#[a-zA-Z0-9]+(?:_[a-zA-Z0-9]+)*" => BaseInteger,
    r"(?:\d+\.\d*|\d*\.\d+|\d+)(?:[eE][-+]?\d+)?f(?:16|32|64|80|128|256)" => FloatingPoint,
}

VecComma<T>: ast::Comma<T> = {
    <mut v:(<T> Comma)*> <e:T?> => {
        if let Some(e) = e {
            v.push(e);
        }
        ast::Comma(v)
    }
};

VecSemi<T>: ast::Semi<T> = {
    <mut v:(<T> Semi)*> <e:T?> => {
        if let Some(e) = e {
            v.push(e);
        }
        ast::Semi(v)
    }
};

VecPipe<T>: ast::Pipe<T> = {
    <mut v:(<T> Or)*> <e:T> => {
        v.push(e);
        ast::Pipe(v)
    }
};

VecAdd<T>: ast::Add<T> = {
    <mut v:(<T> Plus)*> <e:T> => {
        v.push(e);
        ast::Add(v)
    }
};

/// https://doc.rust-lang.org/reference/identifiers.html
Identifier: &'input str = { NonKeywordIdentifier, RawIdentifier };
Ident: ast::Ident = Identifier => ast::Ident {
    inner: <>.to_string()
};


/// https://doc.rust-lang.org/reference/tokens.html
Token: &'input str = {
    If,
    Else,
    As,
    Match,
    Let,
    Return,
    Fn,
    Mut,
    In,
    Pub,
    Mod,
    Struct,
    Entity,
    Enum,
    Const,
    Impl,
    Bag,
    Ring,
    Crate,
    Super,
    LowerSelf,
    UpperSelf,
    TokenType,
    Use,
    Macro,
    For,
    Plus,
    Minus,
    Star,
    StarStar,
    Slash,
    Percent,
    Caret,
    Not,
    And,
    Or,
    AndAnd,
    OrOr,
    Shl,
    Shr,
    PlusEq,
    MinusEq,
    StarEq,
    StarStarEq,
    SlashEq,
    PercentEq,
    CaretEq,
    AndEq,
    OrEq,
    ShlEq,
    ShrEq,
    Eq,
    EqEq,
    Ne,
    Gt,
    Lt,
    Ge,
    Le,
    At,
    Underscore,
    Dot,
    DotDot,
    DotDotEq,
    Comma,
    Semi,
    Colon,
    PathSep,
    RArrow,
    FatArrow,
    Pound,
    Dollar,
    Question,
    Identifier,
    Integer,
    DecimalInteger,
    HexInteger,
    OctalInteger,
    BinaryInteger,
    BaseInteger,
    FloatingPoint,
};

// i.e. 1_234_567_890
Int: Int = Integer => Int::parse(<>).unwrap().into();

pub IntLit: ast::Lit = {
    <val:Int> => ast::Lit::Int { val, suffix: None },

    // i.e. 0d123
    DecimalInteger => {
        const BASE_CHAR: char = 'd';
        const BASE: i32 = 10;
        ast::Lit::Int {
            val: Int::parse_radix(&<>.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            suffix: None,
        }
    },

    // i.e. 0xC0FFEE_CAFE
    HexInteger => {
        const BASE_CHAR: char = 'x';
        const BASE: i32 = 16;
        ast::Lit::Int {
            val: Int::parse_radix(&<>.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            suffix: None,
        }
    },

    // i.e. 0o72
    OctalInteger => {
        const BASE_CHAR: char = 'o';
        const BASE: i32 = 8;
        ast::Lit::Int {
            val: Int::parse_radix(&<>.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            suffix: None,
        }
    },

    // i.e. 0b00110010_00101011_00110010_00111101_00110101
    BinaryInteger => {
        const BASE_CHAR: char = 'b';
        const BASE: i32 = 2;
        ast::Lit::Int {
            val: Int::parse_radix(&<>.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            suffix: None,
        }
    },

    // i.e. 36#HI, an Int in base 36
    BaseInteger => {
        const BASE_CHAR: char = '#';
        let base = <>.split(BASE_CHAR).next().map(i32::from_str).unwrap().unwrap();
        ast::Lit::Int {
            val: Int::parse_radix(&<>.split(BASE_CHAR).nth(1).unwrap(), base).unwrap().into(),
            suffix: None,
        }
    },
};

pub Float: ast::Lit = FloatingPoint => {
    let format = <>.split('f').nth(1).map(usize::from_str).unwrap().unwrap();
    let precision = match format {
        16 => 11,
        32 => 24,
        64 => 53,
        80 => 64,
        128 => 113,
        256 => 237,
        _ => unreachable!()
    };
    let float = Float::parse(<>.split('f').next().unwrap()).unwrap();
    ast::Lit::Float {
        val: Float::with_val(precision, float),
        suffix: None,
    }
};

Lit: ast::Lit = {
    IntLit,
    Float,
};

/// https://doc.rust-lang.org/reference/paths.html#simple-paths
SimplePath: ast::SimplePath = <leading_colon:PathSep?> <mut segments:(<SimplePathSegment> PathSep)*> <last:SimplePathSegment> => {
    segments.push(last);
    ast::SimplePath { leading_colon: leading_colon.map(|_| ()), segments, }
};
SimplePathSegment: ast::Ident = {
    Identifier => ast::Ident { inner: <>.to_string() },
    LowerSelf => ast::Ident { inner: <>.to_string() },
    Super => ast::Ident { inner: <>.to_string() },
    Crate => ast::Ident { inner: <>.to_string() },
};

/// https://doc.rust-lang.org/reference/paths.html#paths-in-expressions
PathInExpression: ast::ExprPath = <leading_colon:PathSep?> <mut segments:(<PathExprSegment> PathSep)*> <last:PathExprSegment> => {
    segments.push(last);
    ast::ExprPath { leading_colon: leading_colon.map(|_| ()), segments, qself: None, }
};
PathExprSegment: ast::ExprPathSegment = SimplePathSegment => ast::ExprPathSegment { ident: <>, args: None, };
GenericArgs: ast::GenericArgs = {
    Lt Gt => ast::GenericArgs { tys: vec![].into(), bindings: vec![].into() },
    Lt <VecComma<Type>> Gt => ast::GenericArgs { tys: <>, bindings: vec![].into() },
    Lt <VecComma<GenericArgsBinding>> Gt => ast::GenericArgs { tys: vec![].into(), bindings: <> },
    Lt <first:Type> <mut rest:(Comma <Type>)*> Comma <bindings:VecComma<GenericArgsBinding>> Gt => ast::GenericArgs { tys: { rest.insert(0, first); ast::Comma(rest) }, bindings, },
};
GenericArgsBinding: ast::GenericArgsBinding = <ident:Ident> Eq <ty:Type> => ast::GenericArgsBinding { ident, ty: Box::new(ty) };

/// TODO: Short-circuit this for now and revisit later
/// https://doc.rust-lang.org/reference/paths.html#qualified-paths
TypePath: ast::ExprPath = PathInExpression;

/// TODO: implement qself
/// https://doc.rust-lang.org/reference/paths.html#qualified-paths
// QualifiedPathInExpression: ast::ExprPath = QualifiedPathType (PathSep PathExprSegment)+;
// QualifiedPathType: = Lt <ty:Type> (As <as:TypePath>)? Gt => QSelf

/// https://doc.rust-lang.org/reference/macros.html
// MacroInvocation: ast::MacroInvocation = <path:SimplePath> Not <tree:DelimTokenTree> => ast::MacroInvocation(path, tree);
// MacroInvocationSemi: ast::MacroInvocation = {
//     <path:SimplePath> Not ParenOpen <tree:TokenTree*> ParenClose Semi => ast::MacroInvocation(path, tree.iter().flatten().map(|x| x.to_string()).collect::<Vec<String>>()),
//     <path:SimplePath> Not BracketOpen <tree:TokenTree*> BracketClose Semi => ast::MacroInvocation(path, tree.iter().flatten().map(|x| x.to_string()).collect::<Vec<String>>()),
//     <path:SimplePath> Not BraceOpen <tree:TokenTree*> BraceClose => ast::MacroInvocation(path, tree.iter().flatten().map(|x| x.to_string()).collect::<Vec<String>>()),
// };

TokenTree: Vec<String> = {
    DelimTokenTree,
    Token => vec![<>.to_string()],
}

DelimTokenTree: Vec<String> = {
    ParenOpen <TokenTree*> ParenClose => <>.iter().flatten().map(|x| x.to_string()).collect::<Vec<String>>(),
    BracketOpen <TokenTree*> BracketClose => <>.iter().flatten().map(|x| x.to_string()).collect::<Vec<String>>(),
    BraceOpen <TokenTree*> BraceClose => <>.iter().flatten().map(|x| x.to_string()).collect::<Vec<String>>(),
};

/// https://doc.rust-lang.org/reference/macros-by-example.html
MacroRulesDef: ast::Semi<ast::MacroRule> = {
    ParenOpen <MacroRules> ParenClose Semi,
    BracketOpen <MacroRules> BracketClose Semi,
    BraceOpen <MacroRules> BraceClose,
};
MacroRules: ast::Semi<ast::MacroRule> = VecSemi<MacroRule>;
MacroRule: ast::MacroRule = <matcher:MacroMatcher> FatArrow <transcriber:MacroTranscriber> => ast::MacroRule(matcher, transcriber);
MacroTranscriber: Vec<String> = DelimTokenTree;
MacroMatcher: ast::MacroMatcher = {
    ParenOpen <MacroMatch*> ParenClose => ast::MacroMatcher(ast::Implicit(<>)),
    BracketOpen <MacroMatch*> BracketClose => ast::MacroMatcher(ast::Implicit(<>)),
    BraceOpen <MacroMatch*> BraceClose => ast::MacroMatcher(ast::Implicit(<>)),
};
MacroMatch: ast::MacroMatch = {
    MacroMatchToken => ast::MacroMatch::Token(<>.to_string()),
    Dollar <ident:Ident> Colon <spec:MacroFragSpec> => ast::MacroMatch::Fragment(ident, ast::MacroFragSpec::from_str(spec).unwrap()),
    Dollar ParenOpen <matches:MacroMatch+> ParenClose <sep:MacroRepSep?> <op:MacroRepOp> => ast::MacroMatch::Rep(ast::Implicit(matches), sep.map(str::to_string), ast::MacroRepOp::from_str(op).unwrap()),
    MacroMatcher => ast::MacroMatch::Matcher(<>),
};

MacroFragSpec: &'input str = {
    BlockTok,
    ExprTok,
    IdentTok,
    ItemTok,
    LitTok,
    MetaTok,
    PatTok,
    PathTok,
    StmtTok,
    TokenTreeTok,
    TypeTok,
    VisTok,
};
MacroRepOp: &'input str = { Plus, Star, Question };
MacroRepSep: &'input str = {
    // Plus,
    Minus,
    // Star,
    StarStar,
    Slash,
    Percent,
    Caret,
    Not,
    And,
    Or,
    AndAnd,
    OrOr,
    Shl,
    Shr,
    PlusEq,
    MinusEq,
    StarEq,
    StarStarEq,
    SlashEq,
    PercentEq,
    CaretEq,
    AndEq,
    OrEq,
    ShlEq,
    ShrEq,
    Eq,
    EqEq,
    Ne,
    Gt,
    Lt,
    Ge,
    Le,
    At,
    Underscore,
    Dot,
    DotDot,
    DotDotEq,
    Comma,
    Semi,
    Colon,
    PathSep,
    RArrow,
    FatArrow,
    Pound,
    Dollar,
    // Question,
};

MacroMatchToken: &'input str = {
    Plus,
    Minus,
    Star,
    StarStar,
    Slash,
    Percent,
    Caret,
    Not,
    And,
    Or,
    AndAnd,
    OrOr,
    Shl,
    Shr,
    PlusEq,
    MinusEq,
    StarEq,
    StarStarEq,
    SlashEq,
    PercentEq,
    CaretEq,
    AndEq,
    OrEq,
    ShlEq,
    ShrEq,
    Eq,
    EqEq,
    Ne,
    Gt,
    Lt,
    Ge,
    Le,
    At,
    Underscore,
    Dot,
    DotDot,
    DotDotEq,
    Comma,
    Semi,
    Colon,
    PathSep,
    RArrow,
    FatArrow,
    Pound,
    // Dollar,
    Question,
};

/// https://doc.rust-lang.org/reference/items.html
Item: ast::Item = {
    /// https://doc.rust-lang.org/reference/items/modules.html
    <vis:Visibility?> Mod <ident:Ident> BraceOpen <items:Item*> BraceClose => ast::Item::Mod(vis.unwrap_or_default(), ident, Some(ast::Implicit(items))),
    <vis:Visibility?> Mod <ident:Ident> Semi => ast::Item::Mod(vis.unwrap_or_default(), ident, None),

    /// https://doc.rust-lang.org/reference/items/use-declarations.html
    <vis:Visibility?> Use <tree:UseTree> Semi => ast::Item::Use(vis.unwrap_or_default(), tree),

    /// https://doc.rust-lang.org/reference/items/functions.html
    <vis:Visibility?> Fn <sig:Sig> <block:Block> => ast::Item::Fn(vis.unwrap_or_default(), sig, block),

    /// https://doc.rust-lang.org/reference/items/type-aliases.html
    <vis:Visibility?> TokenType <ident:Ident> <generics:Generics?> Eq <ty:Type> Semi => ast::Item::Type(vis.unwrap_or_default(), ident, generics.unwrap_or_default(), ty),

    /// https://doc.rust-lang.org/reference/items/structs.html
    <vis:Visibility?> Struct <ident:Ident> <generics:Generics?> <fields:Fields> => ast::Item::Struct(vis.unwrap_or_default(), ident, generics.unwrap_or_default(), fields),

    /// https://doc.rust-lang.org/reference/items/enumerations.html
    <vis:Visibility?> Enum <ident:Ident> <generics:Generics?> BraceOpen <variants:VecComma<Variant>> BraceClose => ast::Item::Enum(vis.unwrap_or_default(), ident, generics.unwrap_or_default(), variants),

    /// https://doc.rust-lang.org/reference/items/constant-items.html
    <vis:Visibility?> Const <ident:Ident> Colon <ty:Type> Eq <expr:Expr> Semi => ast::Item::Const(vis.unwrap_or_default(), ident, ty, expr),

    /// https://doc.rust-lang.org/reference/items/implementations.html
    Impl <generics:Generics?> <path:(<TypePath> For)?> <ty:Type> BraceOpen <items:ImplItem*> BraceClose => ast::Item::Impl(generics.unwrap_or_default(), path, Box::new(ty), ast::Implicit(items)),

    <vis:Visibility?> Entity <ident:Ident> <generics:Generics?> <fields:Fields> => ast::Item::Struct(vis.unwrap_or_default(), ident, generics.unwrap_or_default(), fields),
    <vis:Visibility?> Bag <ident:Ident> ParenOpen <lits:VecComma<Lit>> ParenClose => ast::Item::Bag(vis.unwrap_or_default(), ident, lits),
    <vis:Visibility?> Ring <ident:Ident> ParenOpen <begin:Lit> DotDot <inclusive:Eq?> <end:Lit> ParenClose => ast::Item::Ring(vis.unwrap_or_default(), ident, begin, end, inclusive.is_some()),

    <vis:Visibility?> Macro Not <ident:Ident> <rules:MacroRulesDef> => ast::Item::Macro(vis.unwrap_or_default(), ident, rules),
};

/// https://doc.rust-lang.org/reference/items/use-declarations.html
UseTree: ast::UseTree = {
    // <path:(<SimplePath> PathSep)> BraceOpen <group:VecComma<UseTree>> BraceClose => ast::UseTree::Path(path, Box::new(ast::UseTree::Group(group))),
    // <path:(<SimplePath> PathSep)> Star => ast::UseTree::Path(path, Box::new(ast::UseTree::Glob)),
    // <path:(<SimplePath> PathSep)> As <rename:Ident> => ast::UseTree::Path(path, Box::new(ast::UseTree::Rename(path, rename))),
    SimplePath => ast::UseTree::Name(<>),
};

/// https://doc.rust-lang.org/reference/items/functions.html
Sig: ast::Sig = <ident:Ident> <generics:Generics?> ParenOpen <inputs:FnArgs> ParenClose <output:(RArrow <Type>)?> => ast::Sig {
    ident,
    generics: generics.unwrap_or_default(),
    inputs,
    output,
};
FnArgs: ast::Comma<ast::FnArg> = {
    <receiver:(<LowerSelf>)> => ast::Comma(vec![ast::FnArg::Receiver]),
    <receiver:(<LowerSelf> Comma)> <mut args:VecComma<FnArg>> => {
        args.0.insert(0, ast::FnArg::Receiver);
        args
    },
    VecComma<FnArg>,
};
FnArg: ast::FnArg = PatType => ast::FnArg::Typed(<>);
PatType: ast::PatType = <pat:Pat> Colon <ty:Type> => ast::PatType { pat, ty };

/// https://doc.rust-lang.org/reference/items/structs.html
Fields: ast::Fields = {
    BraceOpen <VecComma<NamedField>> BraceClose => ast::Fields::Named(<>),
    ParenOpen <VecComma<UnnamedField>> ParenClose => ast::Fields::Unnamed(<>),
};
NamedField: ast::NamedField = <vis:Visibility?> <ident:Ident> Colon <ty:Type> => ast::NamedField { vis: vis.unwrap_or_default(), ident, ty };
UnnamedField: ast::UnnamedField = <vis:Visibility?> <ty:Type> => ast::UnnamedField { vis: vis.unwrap_or_default(), ty };

/// https://doc.rust-lang.org/reference/items/enumerations.html
Variant: ast::Variant = {
    <ident:Ident> <fields:Fields?> => ast::Variant::Field(ident, fields.unwrap_or(ast::Fields::Unit)),
    <ident:Ident> Eq <discriminant:Expr> => ast::Variant::Discrim(ident, discriminant),
};

/// https://doc.rust-lang.org/reference/items/implementations.html
ImplItem: ast::ImplItem = {
    <vis:Visibility?> Const <ident:Ident> Colon <ty:Type> Eq <expr:Expr> Semi => ast::ImplItem::Const(vis.unwrap_or_default(), ident, ty, expr),
    <vis:Visibility?> Fn <sig:Sig> <block:Block> => ast::ImplItem::Method(vis.unwrap_or_default(), sig, block),
};

/// https://doc.rust-lang.org/reference/items/generics.html
Generics: ast::Generics = Lt <VecComma<GenericParam>> Gt => ast::Generics { params: <> };

GenericParam: ast::GenericParam = {
    <ident:Ident> Colon <add:VecAdd<TypePath>> <ty:(Eq <Type>)?> => ast::GenericParam::Type(ident, add, ty),
    Const <ident:Ident> Colon <ty:Type> <default:(Eq <Bin3>)?> => ast::GenericParam::Const(ident, ty, default),
};

/// https://doc.rust-lang.org/reference/visibility-and-privacy.html
/// decided not to support crate keyword
Visibility: ast::Vis = {
    Pub => ast::Vis::Pub,
    Pub ParenOpen Super ParenClose => ast::Vis::Pub,
    Pub ParenOpen LowerSelf ParenClose => ast::Vis::Inherited,
    Pub ParenOpen Crate ParenClose => ast::Vis::Crate,
    Pub ParenOpen In <SimplePath> ParenClose => ast::Vis::Restricted(<>),
};

/// https://doc.rust-lang.org/reference/types.html
pub Type: ast::Type = {
    BracketOpen <ty:Type> Semi <expr:IntLit> BracketClose => ast::Type::Array(Box::new(ty), Box::new(expr)),
    TypePath => ast::Type::Path(<>),
    Fn ParenOpen <args:VecComma<Type>> ParenClose RArrow <ret:Type> => ast::Type::Fn(args, Some(Box::new(ret))),
    Fn ParenOpen <args:VecComma<Type>> ParenClose => ast::Type::Fn(args, None),
};

LiteralExpression: ast::Expr = {
    Lit => ast::Expr::Lit(<>),
};

Statement: ast::Stmt = {
    Item => ast::Stmt::Item(<>),
    Let <pat:Pat> <ty:(Colon <Type>)?> <expr:(Eq <Expr>)?> Semi => ast::Stmt::Local(pat, ty, expr),
    <expr:ExprWithoutBlockWithReturn> Semi => ast::Stmt::Expr(expr, true),
    <expr:ExprWithBlock> <semi:Semi?> => ast::Stmt::Expr(expr, semi.is_some()),
};

Statements: Vec<ast::Stmt> = {
    <Statement+>,
    <mut v:Statement+> <e:ExprWithoutBlockWithReturn> => {
        v.push(ast::Stmt::Expr(e, false));
        v
    },
    ExprWithoutBlockWithReturn => vec![ast::Stmt::Expr(<>, false)],
};

Block: ast::Block = {
    BraceOpen <mut v:Statements?> BraceClose => {
        let v = v.unwrap_or_default();
        ast::Block(v)
    },
};
BlockExpression: ast::Expr = Block => ast::Expr::Block(<>);


Unary: ast::Expr = {
    Minus <expr:ExprWithoutBlockOrOperator> => ast::Expr::Unary(ast::UnOp::Neg, Box::new(expr)),
    Minus <expr:ExprWithBlock> => ast::Expr::Unary(ast::UnOp::Neg, Box::new(expr)),

    Not <expr:ExprWithoutBlockOrOperator> => ast::Expr::Unary(ast::UnOp::Not, Box::new(expr)),
    Not <expr:ExprWithBlock> => ast::Expr::Unary(ast::UnOp::Not, Box::new(expr)),

    ExprWithoutBlockOrOperator,
};

Cast: ast::Expr = {
    <expr:Unary> As <ty:Type> => ast::Expr::Cast(Box::new(expr), Box::new(ty)),
    <expr:ExprWithBlock> As <ty:Type> => ast::Expr::Cast(Box::new(expr), Box::new(ty)),

    Unary,
};

Arith0: ast::Expr = {
    <l:Arith0> StarStar <r:Cast> => ast::Expr::Binary(Box::new(l), ast::BinOp::Exp, Box::new(r)),
    <l:Arith0> StarStar <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Exp, Box::new(r)),

    Cast,
};

Arith1: ast::Expr = {
    <l:Arith1> Slash <r:Arith0> => ast::Expr::Binary(Box::new(l), ast::BinOp::Div, Box::new(r)),
    <l:Arith1> Slash <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Div, Box::new(r)),

    <l:Arith1> Percent <r:Arith0> => ast::Expr::Binary(Box::new(l), ast::BinOp::Rem, Box::new(r)),
    <l:Arith1> Percent <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Rem, Box::new(r)),

    <l:Arith1> Star <r:Arith0> => ast::Expr::Binary(Box::new(l), ast::BinOp::Mul, Box::new(r)),
    <l:Arith1> Star <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Mul, Box::new(r)),

    Arith0,
};

Arith2: ast::Expr = {
    <l:Arith2> Plus <r:Arith1> => ast::Expr::Binary(Box::new(l), ast::BinOp::Add, Box::new(r)),
    <l:Arith2> Plus <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Add, Box::new(r)),

    <l:Arith2> Minus <r:Arith1> => ast::Expr::Binary(Box::new(l), ast::BinOp::Sub, Box::new(r)),
    <l:Arith2> Minus <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Sub, Box::new(r)),

    Arith1,
};

Bin0: ast::Expr = {
    <l:Bin0> Shr <r:Arith2> => ast::Expr::Binary(Box::new(l), ast::BinOp::Shr, Box::new(r)),
    <l:Bin0> Shr <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Shr, Box::new(r)),

    <l:Bin0> Shl <r:Arith2> => ast::Expr::Binary(Box::new(l), ast::BinOp::Shl, Box::new(r)),
    <l:Bin0> Shl <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Shl, Box::new(r)),

    Arith2,
};

Bin1: ast::Expr = {
    <l:Bin1> And <r:Bin0> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitAnd, Box::new(r)),
    <l:Bin1> And <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitAnd, Box::new(r)),

    Bin0,
};

Bin2: ast::Expr = {
    <l:Bin2> Caret <r:Bin1> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitXor, Box::new(r)),
    <l:Bin2> Caret <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitXor, Box::new(r)),

    Bin1,
};

Bin3: ast::Expr = {
    <l:Bin3> Or <r:Bin2> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitOr, Box::new(r)),
    <l:Bin3> Or <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitOr, Box::new(r)),

    Bin2,
};

ComparisonExpression: ast::Expr = {
    <l:Bin3> EqEq <r:Bin3> => ast::Expr::Binary(Box::new(l), ast::BinOp::Eq, Box::new(r)),
    <l:Bin3> EqEq <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Eq, Box::new(r)),

    <l:Bin3> Ne <r:Bin3> => ast::Expr::Binary(Box::new(l), ast::BinOp::Ne, Box::new(r)),
    <l:Bin3> Ne <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Ne, Box::new(r)),

    <l:Bin3> Lt <r:Bin3> => ast::Expr::Binary(Box::new(l), ast::BinOp::Lt, Box::new(r)),
    <l:Bin3> Lt <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Lt, Box::new(r)),

    <l:Bin3> Le <r:Bin3> => ast::Expr::Binary(Box::new(l), ast::BinOp::Le, Box::new(r)),
    <l:Bin3> Le <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Le, Box::new(r)),

    <l:Bin3> Gt <r:Bin3> => ast::Expr::Binary(Box::new(l), ast::BinOp::Gt, Box::new(r)),
    <l:Bin3> Gt <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Gt, Box::new(r)),

    <l:Bin3> Ge <r:Bin3> => ast::Expr::Binary(Box::new(l), ast::BinOp::Ge, Box::new(r)),
    <l:Bin3> Ge <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Ge, Box::new(r)),
    Bin3,
};

AssignExpression: ast::Expr = {
    <l:ComparisonExpression> Eq <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::Eq, Box::new(r)),
    <l:ComparisonExpression> Eq <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::Eq, Box::new(r)),

    <l:ComparisonExpression> PlusEq <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::AddEq, Box::new(r)),
    <l:ComparisonExpression> PlusEq <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::AddEq, Box::new(r)),

    <l:ComparisonExpression> MinusEq <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::SubEq, Box::new(r)),
    <l:ComparisonExpression> MinusEq <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::SubEq, Box::new(r)),

    <l:ComparisonExpression> StarEq <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::MulEq, Box::new(r)),
    <l:ComparisonExpression> StarEq <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::MulEq, Box::new(r)),

    <l:ComparisonExpression> StarStarEq <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::ExpEq, Box::new(r)),
    <l:ComparisonExpression> StarStarEq <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::ExpEq, Box::new(r)),

    <l:ComparisonExpression> SlashEq <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::DivEq, Box::new(r)),
    <l:ComparisonExpression> SlashEq <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::DivEq, Box::new(r)),

    <l:ComparisonExpression> PercentEq <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::RemEq, Box::new(r)),
    <l:ComparisonExpression> PercentEq <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::RemEq, Box::new(r)),

    <l:ComparisonExpression> AndEq <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::BitAndEq, Box::new(r)),
    <l:ComparisonExpression> AndEq <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::BitAndEq, Box::new(r)),

    <l:ComparisonExpression> OrEq <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::BitOrEq, Box::new(r)),
    <l:ComparisonExpression> OrEq <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::BitOrEq, Box::new(r)),
    
    <l:ComparisonExpression> CaretEq <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::BitXorEq, Box::new(r)),
    <l:ComparisonExpression> CaretEq <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::BitXorEq, Box::new(r)),

    <l:ComparisonExpression> ShlEq <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::ShlEq, Box::new(r)),
    <l:ComparisonExpression> ShlEq <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::ShlEq, Box::new(r)),

    <l:ComparisonExpression> ShrEq <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::ShrEq, Box::new(r)),
    <l:ComparisonExpression> ShrEq <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::ShrEq, Box::new(r)),

    ComparisonExpression,
};

OperatorExpression: ast::Expr = AssignExpression;

GroupedExpression: ast::Expr = ParenOpen <Expr> ParenClose;

ArrayExpression: ast::Expr = {
    BracketOpen <val:Expr> Semi <repeat:Expr> BracketClose => ast::Expr::Repeat(Box::new(val), Box::new(repeat)),
    BracketOpen <VecComma<Expr>> BracketClose => ast::Expr::Array(<>),
};

IndexExpression: ast::Expr = <on:ExprWithoutBlockOrOperator> BracketOpen <index:Expr> BracketClose => ast::Expr::Index(Box::new(on), Box::new(index));

TupleElements: Vec<ast::Expr> = <mut v:(<Expr> Comma)+> <e:Expr?> => {
    if let Some(e) = e {
        v.push(e);
    }
    v
};
TupleExpression: ast::Expr = ParenOpen <TupleElements?> ParenClose => ast::Expr::Tuple(ast::Comma(<>.unwrap_or_default()));


TupleIndexingExpression: ast::Expr = {
    <base:ExprWithBlock> Dot <unnamed:Int> => ast::Expr::Field(Box::new(base), ast::Member::Unnamed(unnamed)),
    <base:ExprWithoutBlockOrOperator> Dot <unnamed:Int> => ast::Expr::Field(Box::new(base), ast::Member::Unnamed(unnamed)),
};

FieldValue: ast::FieldValue = {
    <named:Ident> Colon <expr:Expr> => ast::FieldValue { member: ast::Member::Named(named), expr: Some(expr), },
    <unnamed:Int> Colon <expr:Expr> => ast::FieldValue { member: ast::Member::Unnamed(unnamed), expr: Some(expr), },
    <named:Ident> => ast::FieldValue { member: ast::Member::Named(named.clone()), expr: None, },
};

StructExpression: ast::Expr = {
    <path:PathInExpression> BraceOpen <first:FieldValue> <mut rest:(Comma <FieldValue>)*> <base:((Comma DotDot <Expr>)? Comma?)> BraceClose => {
        let mut fields = vec![first];
        fields.append(&mut rest);
        ast::Expr::Struct(path, fields.into(), base.0.map(Box::new))
    },
    <path:PathInExpression> BraceOpen <base:(DotDot <Expr> Comma?)> BraceClose => {
        ast::Expr::Struct(path, vec![].into(), Some(Box::new(base)))
    },
    <path:PathInExpression> BraceOpen BraceClose => {
        ast::Expr::Struct(path, vec![].into(), None)
    },
};

CallExpression: ast::Expr = <func:ExprWithoutFieldOrBlock> ParenOpen <args:VecComma<Expr>> ParenClose => ast::Expr::Call(Box::new(func), args);

MethodCallExpression: ast::Expr = {
    <receiver:ExprWithBlock> Dot <method:PathExprSegment> ParenOpen <args:VecComma<Expr>> ParenClose => ast::Expr::MethodCall(Box::new(receiver), method, args),
    <receiver:ExprWithoutBlockOrOperator> Dot <method:PathExprSegment> ParenOpen <args:VecComma<Expr>> ParenClose => ast::Expr::MethodCall(Box::new(receiver), method, args),
};

FieldExpression: ast::Expr = {
    <base:ExprWithBlock> Dot <named:Ident> => ast::Expr::Field(Box::new(base), ast::Member::Named(named)),
    <base:ExprWithoutBlockOrOperator> Dot <named:Ident> => ast::Expr::Field(Box::new(base), ast::Member::Named(named)),
};

// todo: closure expression

RangeExpression: ast::Expr = {
    <l:LiteralExpression?> DotDot <r:LiteralExpression?> => ast::Expr::Range(l.map(|l| Box::new(l)), r.map(|r| Box::new(r)), false),
    <l:LiteralExpression?> DotDotEq <r:LiteralExpression> => ast::Expr::Range(l.map(|l| Box::new(l)), Some(Box::new(r)), true),
};

CondIf: ast::Expr = If <ExprWithoutStruct>;

// todo: if let expression
pub IfExpression: ast::Expr = {
    <c:CondIf> <b:BlockExpression> <els:(Else <IfExpression>)> => ast::Expr::If(Box::new(c), Box::new(b), Some(Box::new(els))),
    <c:CondIf> <b:BlockExpression> <els:(Else <BlockExpression>)?> => ast::Expr::If(Box::new(c), Box::new(b), els.map(Box::new)),
};

MatchArm: ast::Arm = {
    <pat:Pat> <guard:CondIf?> FatArrow <body:Expr> => ast::Arm {
        pat,
        guard,
        body,
    },
};

MatchExpression: ast::Expr = Match <e:ExprWithoutStruct> BraceOpen <arms:VecComma<MatchArm>> BraceClose => ast::Expr::Match(Box::new(e), arms);

ReturnExpression: ast::Expr = Return <Expr?> => ast::Expr::Return(<>.map(Box::new));

ExprWithoutFieldOrBlock: ast::Expr = {
    LiteralExpression,
    PathInExpression => ast::Expr::Path(<>),
    GroupedExpression,
    ArrayExpression,
    IndexExpression,
    TupleIndexingExpression,
    CallExpression,
    MethodCallExpression,
    RangeExpression,
};

ExprWithoutBlockOrOperator: ast::Expr = {
    ExprWithoutFieldOrBlock,
    FieldExpression,
};

ExprWithoutBlockWithReturn: ast::Expr = {
    OperatorExpression,
    ReturnExpression,
};

ExprWithBlock: ast::Expr = {
    BlockExpression,
    IfExpression,
    MatchExpression,
};

ExprWithoutStruct: ast::Expr = {
    OperatorExpression,
    ExprWithBlock,
};

pub Expr: ast::Expr = {
    ExprWithoutStruct,
    StructExpression,
};


/// https://doc.rust-lang.org/reference/patterns.html
pub Pat: ast::Pat = {
    /// https://doc.rust-lang.org/reference/patterns.html#literal-patterns
    Lit => ast::Pat::Lit(<>),
    /// https://doc.rust-lang.org/reference/patterns.html#identifier-patterns and https://doc.rust-lang.org/reference/patterns.html#path-patterns
    PathInExpression => {
        if <>.leading_colon.is_none() && <>.qself.is_none() && <>.segments.len() == 1 {
            if let Some(ast::ExprPathSegment { ident, args: None, }) = <>.segments.first() {
                ast::Pat::Ident(ident.clone())
            } else {
                ast::Pat::Path(<>)
            }
        } else {
            ast::Pat::Path(<>)
        }
    },
    /// https://doc.rust-lang.org/reference/patterns.html#wildcard-pattern
    Underscore => ast::Pat::Wildcard,
    /// https://doc.rust-lang.org/reference/patterns.html#range-patterns
    <l:RangePatternBound> DotDot <r:RangePatternBound> => ast::Pat::Range(l, false, r),
    <l:RangePatternBound> DotDotEq <r:RangePatternBound> => ast::Pat::Range(l, true, r),
    /// https://doc.rust-lang.org/reference/patterns.html#struct-patterns
    <path:PathInExpression> BraceOpen <elems:StructPatternElements> BraceClose => ast::Pat::Struct(path, elems.0, elems.1),
    /// https://doc.rust-lang.org/reference/patterns.html#tuple-struct-patterns
    <path: PathInExpression> ParenOpen <pats:VecComma<Pat>> ParenClose => ast::Pat::TupleStruct(path, pats, None),
    <path: PathInExpression> ParenOpen <left:(<Pat> Comma)*> DotDot Comma <right:VecComma<Pat>> ParenClose => ast::Pat::TupleStruct(path, ast::Comma(left), Some(right)),
    /// https://doc.rust-lang.org/reference/patterns.html#tuple-patterns and https://doc.rust-lang.org/reference/patterns.html#grouped-patterns
    ParenOpen <VecComma<Pat>> ParenClose => ast::Pat::Tuple(<>, None),
    ParenOpen <left:(<Pat> Comma)*> DotDot Comma <right:VecComma<Pat>> ParenClose => ast::Pat::Tuple(ast::Comma(left), Some(right)),
    /// https://doc.rust-lang.org/reference/patterns.html#slice-patterns
    BraceOpen <VecComma<Pat>> BraceClose => ast::Pat::Slice(<>),

    // MacroInvocation => ast::Pat::Macro(<>),
};

RangePatternBound: ast::Expr = {
    LiteralExpression,
    PathInExpression => ast::Expr::Path(<>),
};

StructPatternElements: (ast::Comma<ast::StructPatternField>, Option<()>) = {
    DotDot => (ast::Comma(vec![]), Some(())),
    <first:StructPatternField> <mut rest:(Comma <StructPatternField>)*> Comma? => (ast::Comma({ rest.insert(0, first); rest }), None),
    <first:StructPatternField> <mut rest:(Comma <StructPatternField>)*> Comma DotDot => (ast::Comma({ rest.insert(0, first); rest }), Some(())),
};

StructPatternField: ast::StructPatternField = {
    <val:Int> <pat:Pat> => ast::StructPatternField::TuplePat(val, Box::new(pat)),
    <ident:Ident> <pat:Pat> => ast::StructPatternField::IdentPat(ident, Box::new(pat)),
    Ident => ast::StructPatternField::Ident(<>),
};
