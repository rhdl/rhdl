use rug::{Integer as Int, Float};

use std::str::FromStr;

use crate::ast;

grammar;

/// https://doc.rust-lang.org/reference/identifiers.html
/// raw identifiers are not supported (for now)

match {
    "if" => If,
    "else" => Else,
    "as" => As,
    "match" => Match,
    "let" => Let,
    "return" => Return,
    "fn" => Fn,
    "mut" => Mut,
    "in" => In,
    "pub" => Pub,
    "mod" => Mod,
    "struct" => Struct,
    "entity" => Entity,
    "enum" => Enum,
    "const" => Const,
    "impl" => Impl,
    "bag" => Bag,
    "ring" => Ring,
    "crate" => Crate,
    "super" => Super,
    "self" => LowerSelf,
    "Self" => UpperSelf,
    "type" => TokenType,
    "use" => Use,
    "(break|continue|extern|false|for|loop|move|mut|ref|static|trait|true|unsafe|where|while|async|await|dyn|abstract|become|box|do|final|macro|override|priv|typeof|unsized|virtual|yield|try|union)" => Keyword,
} else {
    r"(?:[a-zA-Z][a-zA-Z0-9_]*|_[a-z A-Z 0-9 _]+)" => Identifier,
    _
}

Ident: ast::Ident = Identifier => ast::Ident {
    inner: <>.to_string()
};

PathIdentSegment: ast::Ident = Ident;
    // r"(super|self|Self|crate|$crate)" => ast::Ident { inner: <>.to_string() },

Comma<T>: ast::Comma<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => ast::Comma(v),
        Some(e) => {
            let mut v = v;
            v.push(e);
            ast::Comma(v)
        }
    }
};

Pipe<T>: Vec<T> = {
    <v:(<T> "|")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Add<T>: ast::Add<T> = {
    <mut v:(<T> "+")*> <e:T> => {
        v.push(e);
        ast::Add(v)
    }
};

Path: ast::Path = {
    <leading_colon:"::"?> <path:(<Ident> "::")*> <final_path:Ident> => {
        let mut v = path;
        v.push(final_path);
        ast::Path {
            leading_colon: leading_colon.map(|_| ()),
            segments: v,
        }
    }
};

// Field<T>: (ast::Ident, ast::Expr) = {
//     <v:(<T> ":")*> <e:T?> => match e {
//         None => v,
//         Some(e) => {
//             let mut v = v;
//             v.push(e);
//             v
//         }
//     }
// };


pub Type: ast::Type = {
    "[" <ty:Type> ";" <expr:IntLit> "]" => ast::Type::Array(Box::new(ty), Box::new(expr)),
    Path => ast::Type::Path(<>),
    Fn "(" <args:Comma<Type>> ")" "->" <ret:Type> => ast::Type::Fn(args, Some(Box::new(ret))),
    Fn "(" <args:Comma<Type>> ")" => ast::Type::Fn(args, None),
};

// i.e. 1_234_567_890
Int: Int = r"(0|[1-9]\d*(?:_\d+)*)" => Int::parse(<>).unwrap().into();

pub IntLit: ast::Lit = {
    Int => ast::Lit::Int { val: <>, type_hint: None },

    // i.e. 0xC0FFEE_CAFE
    r"0d\d+(?:_\d+)*" => {
        const BASE_CHAR: char = 'd';
        const BASE: i32 = 10;
        ast::Lit::Int {
            val: Int::parse_radix(&<>.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            type_hint: None,
        }
    },

    // i.e. 0xC0FFEE_CAFE
    r"0x[0-9a-fA-F]+(?:_[0-9a-fA-F]+)*" => {
        const BASE_CHAR: char = 'x';
        const BASE: i32 = 16;
        ast::Lit::Int {
            val: Int::parse_radix(&<>.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            type_hint: None,
        }
    },

    // i.e. 0o72
    r"0o[0-7]+(?:_[0-7]+)*" => {
        const BASE_CHAR: char = 'o';
        const BASE: i32 = 8;
        ast::Lit::Int {
            val: Int::parse_radix(&<>.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            type_hint: None,
        }
    },

    // i.e. 0b00110010_00101011_00110010_00111101_00110101
    r"0b[01]+(?:_[01]+)*" => {
        const BASE_CHAR: char = 'b';
        const BASE: i32 = 2;
        ast::Lit::Int {
            val: Int::parse_radix(&<>.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            type_hint: None,
        }
    },

    // i.e. 36#HI, an Int in base 36
    r"(?:2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36)#[a-zA-Z0-9]+(?:_[a-zA-Z0-9]+)*" => {
        const BASE_CHAR: char = '#';
        let base = <>.split(BASE_CHAR).next().map(i32::from_str).unwrap().unwrap();
        ast::Lit::Int {
            val: Int::parse_radix(&<>.split(BASE_CHAR).nth(1).unwrap(), base).unwrap().into(),
            type_hint: None,
        }
    },
};

pub Float: ast::Lit = r"(?:\d+\.\d*|\d*\.\d+|\d+)(?:[eE][-+]?\d+)?f(?:16|32|64|80|128|256)" => {
    let format = <>.split('f').nth(1).map(usize::from_str).unwrap().unwrap();
    let precision = match format {
        16 => 11,
        32 => 24,
        64 => 53,
        80 => 64,
        128 => 113,
        256 => 237,
        _ => unreachable!()
    };
    let float = Float::parse(<>.split('f').next().unwrap()).unwrap();
    ast::Lit::Float {
        val: Float::with_val(precision, float)
    }
};

Lit: ast::Lit = {
    IntLit,
    Float,
};

LiteralExpression: ast::Expr = {
    Lit => ast::Expr::Lit(<>),
};

PathExpression: ast::Expr = Path => ast::Expr::Path(<>);


Statement: ast::Stmt = {
    Item => ast::Stmt::Item(<>),
    Let <pat:Pat> <ty:(":" <Type>)?> <expr:("=" <Expr>)?> ";" => ast::Stmt::Local(pat, ty, expr),
    <expr:ExprWithoutBlockWithReturn> ";" => ast::Stmt::Expr(expr, true),
    <expr:ExprWithBlock> <semi:";"?> => ast::Stmt::Expr(expr, semi.is_some()),
};

Statements: Vec<ast::Stmt> = {
    <Statement+>,
    <mut v:Statement+> <e:ExprWithoutBlockWithReturn> => {
        v.push(ast::Stmt::Expr(e, false));
        v
    },
    ExprWithoutBlockWithReturn => vec![ast::Stmt::Expr(<>, false)],
};

Block: ast::Block = {
    "{" <mut v:Statements?> "}" => {
        let v = v.unwrap_or_default();
        ast::Block(v)
    },
};
BlockExpression: ast::Expr = Block => ast::Expr::Block(<>);


Unary: ast::Expr = {
    "-" <expr:ExprWithoutBlockOrOperator> => ast::Expr::Unary(ast::UnOp::Neg, Box::new(expr)),
    "-" <expr:ExprWithBlock> => ast::Expr::Unary(ast::UnOp::Neg, Box::new(expr)),
    "!" <expr:ExprWithoutBlockOrOperator> => ast::Expr::Unary(ast::UnOp::Not, Box::new(expr)),
    "!" <expr:ExprWithBlock> => ast::Expr::Unary(ast::UnOp::Not, Box::new(expr)),
    ExprWithoutBlockOrOperator,
};

Cast: ast::Expr = {
    <expr:Unary> As <ty:Type> => ast::Expr::Cast(Box::new(expr), Box::new(ty)),
    <expr:ExprWithBlock> As <ty:Type> => ast::Expr::Cast(Box::new(expr), Box::new(ty)),
    Unary,
};

Arith0: ast::Expr = {
    <l:Arith0> "**" <r:Cast> => ast::Expr::Binary(Box::new(l), ast::BinOp::Exp, Box::new(r)),
    <l:Arith0> "**" <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Exp, Box::new(r)),
    // <l:ExprWithBlock> "**" <r:Cast> => ast::Expr::Binary(Box::new(l), ast::BinOp::Exp, Box::new(r)),
    // <l:ExprWithBlock> "**" <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::Exp, Box::new(r)),
    Cast,
};

Arith1: ast::Expr = {
    <l:Arith1> <op:r"/|%"> <r:Arith0> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    <l:Arith1> <op:r"/|%"> <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),

    <l:Arith1> <op:"*"> <r:Arith0> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    <l:Arith1> <op:"*"> <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    // <l:ExprWithBlock> <op:r"\*|/|%"> <r:Arith0> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    // <l:ExprWithBlock> <op:r"\*|/|%"> <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    Arith0,
};

Arith2: ast::Expr = {
    <l:Arith2> <op:"+"> <r:Arith1> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    <l:Arith2> <op:"+"> <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    // <l:ExprWithBlock> <op:"+"> <r:Arith1> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    // <l:ExprWithBlock> <op:"+"> <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),

    <l:Arith2> <op:"-"> <r:Arith1> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    <l:Arith2> <op:"-"> <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    // <l:ExprWithBlock> <op:"-"> <r:Arith1> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    // <l:ExprWithBlock> <op:"-"> <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    Arith1,
};

Bin0: ast::Expr = {
    <l:Bin0> <op:r"<<|>>"> <r:Arith2> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    <l:Bin0> <op:r"<<|>>"> <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    // <l:ExprWithBlock> <op:r"<<|>>"> <r:Arith2> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    // <l:ExprWithBlock> <op:r"<<|>>"> <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    Arith2,
};

Bin1: ast::Expr = {
    <l:Bin1> "&" <r:Bin0> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitAnd, Box::new(r)),
    <l:Bin1> "&" <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitAnd, Box::new(r)),
    // <l:ExprWithBlock> "&" <r:Bin0> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitAnd, Box::new(r)),
    // <l:ExprWithBlock> "&" <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitAnd, Box::new(r)),
    Bin0,
};

Bin2: ast::Expr = {
    <l:Bin2> "^" <r:Bin1> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitXor, Box::new(r)),
    <l:Bin2> "^" <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitXor, Box::new(r)),
    // <l:ExprWithBlock> "^" <r:Bin1> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitXor, Box::new(r)),
    // <l:ExprWithBlock> "^" <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitXor, Box::new(r)),
    Bin1,
};

Bin3: ast::Expr = {
    <l:Bin3> "|" <r:Bin2> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitOr, Box::new(r)),
    <l:Bin3> "|" <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitOr, Box::new(r)),
    // <l:ExprWithBlock> "|" <r:Bin2> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitOr, Box::new(r)),
    // <l:ExprWithBlock> "|" <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::BitOr, Box::new(r)),
    Bin2,
};

ComparisonExpression: ast::Expr = {
    <l:Bin3> <op:r"<=|>=|==|!="> <r:Bin3> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    <l:Bin3> <op:r"<=|>=|==|!="> <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),

    <l:Bin3> <op:"<"> <r:Bin3> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    <l:Bin3> <op:"<"> <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    <l:Bin3> <op:">"> <r:Bin3> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    <l:Bin3> <op:">"> <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    // <l:ExprWithBlock> <op:r"<=|<|>=|>|==|!="> <r:Bin3> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    // <l:ExprWithBlock> <op:r"<=|<|>=|>|==|!="> <r:ExprWithBlock> => ast::Expr::Binary(Box::new(l), ast::BinOp::from_str(op).unwrap(), Box::new(r)),
    Bin3,
};

AssignExpression: ast::Expr = {
    <l:ComparisonExpression> <op:r"(\+|-|\*|\*\*|/|%|&|\||\^|<<|>>)="> <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::from_str(op).unwrap(), Box::new(r)),
    <l:ComparisonExpression> <op:r"(\+|-|\*|\*\*|/|%|&|\||\^|<<|>>)="> <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::from_str(op).unwrap(), Box::new(r)),
    // <l:ExprWithBlock> <op:r"(\+|-|\*|\*\*|/|%|&|\||\^|<<|>>)="> <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::from_str(op).unwrap(), Box::new(r)),
    // <l:ExprWithBlock> <op:r"(\+|-|\*|\*\*|/|%|&|\||\^|<<|>>)="> <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::from_str(op).unwrap(), Box::new(r)),

    <l:ComparisonExpression> <op:"="> <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::from_str(op).unwrap(), Box::new(r)),
    <l:ComparisonExpression> <op:"="> <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::from_str(op).unwrap(), Box::new(r)),
    // <l:ExprWithBlock> <op:"="> <r:ComparisonExpression> => ast::Expr::Assign(Box::new(l), ast::AssOp::from_str(op).unwrap(), Box::new(r)),
    // <l:ExprWithBlock> <op:"="> <r:ExprWithBlock> => ast::Expr::Assign(Box::new(l), ast::AssOp::from_str(op).unwrap(), Box::new(r)),
    ComparisonExpression,
};

OperatorExpression: ast::Expr = AssignExpression;

GroupedExpression: ast::Expr = "(" <Expr> ")";

ArrayExpression: ast::Expr = {
    "[" <val:Expr> ";" <repeat:Expr> "]" => ast::Expr::Repeat(Box::new(val), Box::new(repeat)),
    "[" <Comma<Expr>> "]" => ast::Expr::Array(<>),
};

IndexExpression: ast::Expr = <on:ExprWithoutBlockOrOperator> "[" <index:Expr> "]" => ast::Expr::Index(Box::new(on), Box::new(index));

TupleElements: Vec<ast::Expr> = <mut v:(<Expr> ",")+> <e:Expr?> => {
    if let Some(e) = e {
        v.push(e);
    }
    v
};
TupleExpression: ast::Expr = "(" <TupleElements?> ")" => ast::Expr::Tuple(ast::Comma(<>.unwrap_or_default()));


TupleIndexingExpression: ast::Expr = {
    <base:ExprWithBlock> "." <unnamed:Int> => ast::Expr::Field(Box::new(base), ast::Member::Unnamed(unnamed)),
    <base:ExprWithoutBlockOrOperator> "." <unnamed:Int> => ast::Expr::Field(Box::new(base), ast::Member::Unnamed(unnamed)),
};

FieldValue: ast::FieldValue = {
    <named:Ident> ":" <expr:Expr> => ast::FieldValue { member: ast::Member::Named(named), expr, },
    <unnamed:Int> ":" <expr:Expr> => ast::FieldValue { member: ast::Member::Unnamed(unnamed), expr, },
    <named:Ident> => ast::FieldValue { member: ast::Member::Named(named.clone()), expr: ast::Expr::Path(ast::Path { leading_colon: None, segments: vec![named] }), },
};

StructExpression: ast::Expr = {
    <path:Path> "{" <first:FieldValue> <mut rest:("," <FieldValue>)*> <base:(("," ".." <Expr>)? ","?)> "}" => {
        let mut fields = vec![first];
        fields.append(&mut rest);
        ast::Expr::Struct(path, fields.into(), base.0.map(Box::new))
    },
    <path:Path> "{" <base:(".." <Expr> ","?)> "}" => {
        ast::Expr::Struct(path, vec![].into(), Some(Box::new(base)))
    },
    <path:Path> "{" "}" => {
        ast::Expr::Struct(path, vec![].into(), None)
    },
};

CallExpression: ast::Expr = <func:ExprWithoutFieldOrBlock> "(" <args:Comma<Expr>> ")" => ast::Expr::Call(Box::new(func), args);

MethodCallExpression: ast::Expr = {
    <receiver:ExprWithBlock> "." <method:PathIdentSegment> "(" <args:Comma<Expr>> ")" => ast::Expr::MethodCall(Box::new(receiver), method, args),
    <receiver:ExprWithoutBlockOrOperator> "." <method:PathIdentSegment> "(" <args:Comma<Expr>> ")" => ast::Expr::MethodCall(Box::new(receiver), method, args),
};

FieldExpression: ast::Expr = {
    <base:ExprWithBlock> "." <named:Ident> => ast::Expr::Field(Box::new(base), ast::Member::Named(named)),
    <base:ExprWithoutBlockOrOperator> "." <named:Ident> => ast::Expr::Field(Box::new(base), ast::Member::Named(named)),
};

// todo: closure expression

RangeExpression: ast::Expr = {
    <l:LiteralExpression?> ".." <r:LiteralExpression?> => ast::Expr::Range(l.map(|l| Box::new(l)), r.map(|r| Box::new(r)), false),
    <l:LiteralExpression?> "..=" <r:LiteralExpression> => ast::Expr::Range(l.map(|l| Box::new(l)), Some(Box::new(r)), true),
};

CondIf: ast::Expr = If <ExprWithoutStruct>;

// todo: if let expression
pub IfExpression: ast::Expr = {
    <c:CondIf> <b:BlockExpression> <els:(Else <IfExpression>)> => ast::Expr::If(Box::new(c), Box::new(b), Some(Box::new(els))),
    <c:CondIf> <b:BlockExpression> <els:(Else <BlockExpression>)?> => ast::Expr::If(Box::new(c), Box::new(b), els.map(Box::new)),
};

MatchArm: ast::Arm = {
    <pat:Pat> <guard:CondIf?> "=>" <body:Expr> => ast::Arm {
        pat,
        guard,
        body,
    },
};

MatchExpression: ast::Expr = Match <e:ExprWithoutStruct> "{" <arms:Comma<MatchArm>> "}" => ast::Expr::Match(Box::new(e), arms);

ReturnExpression: ast::Expr = Return <Expr?> => ast::Expr::Return(<>.map(Box::new));

ExprWithoutFieldOrBlock: ast::Expr = {
    LiteralExpression,
    PathExpression,
    GroupedExpression,
    ArrayExpression,
    IndexExpression,
    TupleIndexingExpression,
    CallExpression,
    MethodCallExpression,
    RangeExpression,
};

ExprWithoutBlockOrOperator: ast::Expr = {
    ExprWithoutFieldOrBlock,
    FieldExpression,
};

ExprWithoutBlockWithReturn: ast::Expr = {
    OperatorExpression,
    ReturnExpression,
};

ExprWithBlock: ast::Expr = {
    BlockExpression,
    IfExpression,
    MatchExpression,
};

ExprWithoutStruct: ast::Expr = {
    OperatorExpression,
    ExprWithBlock,
};

pub Expr: ast::Expr = {
    ExprWithoutStruct,
    StructExpression,
};

PatType: ast::PatType = <pat:Pat> ":" <ty:Type> => ast::PatType { pat: Box::new(pat), ty };

pub Pat: ast::Pat = {
    Ident => ast::Pat::Ident(<>),
    IntLit => ast::Pat::Lit(<>),
}

Visibility: ast::Vis = {
    Pub => ast::Vis::Pub,
    Crate => ast::Vis::Crate,
    Pub "(" Super ")" => ast::Vis::Pub,
    Pub "(" LowerSelf ")" => ast::Vis::Inherited,
    Pub "(" Crate ")" => ast::Vis::Crate,
    Pub "(" In <Path> ")" => ast::Vis::Restricted(<>),
};

Field: ast::Field = <ident: Ident> ":" <ty:Type> => ast::Field { ident, ty };

Fields: ast::Fields = {
    "{" <Comma<Field>> "}" => ast::Fields::Named(<>),
    "(" <Comma<Type>> ")" => ast::Fields::Unnamed(<>),
};

Variant: ast::Variant = <ident:Ident> <fields:Fields?> <discriminant:("=" <Expr>)?> => ast::Variant { ident, fields: fields.unwrap_or(ast::Fields::Unit), discriminant };

GenericParam: ast::GenericParam = {
    <ident:Ident> <add:Add<Path>> <ty:("=" <Type>)?> => ast::GenericParam::Type(ident, add, ty),
    Const <ident:Ident> ":" <ty:Type> <default:("=" <Bin3>)?> => ast::GenericParam::Const(ident, ty, default),
};
Generics: ast::Generics = "<" <Comma<GenericParam>> ">" => ast::Generics { params: <> };

FnArg: ast::FnArg = PatType => ast::FnArg::Typed(<>);

FnArgs: ast::Comma<ast::FnArg> = {
    <receiver:(<LowerSelf>)> => ast::Comma(vec![ast::FnArg::Receiver]),
    <receiver:(<LowerSelf> ",")> <mut args:Comma<FnArg>> => {
        args.0.insert(0, ast::FnArg::Receiver);
        args
    },
    Comma<FnArg>,
};

Sig: ast::Sig = <ident:Ident> <generics:Generics?> "(" <inputs:FnArgs> ")" <output:("->" <Type>)?> => ast::Sig {
    ident,
    generics: generics.unwrap_or_default(),
    inputs,
    output,
};

UseTree: ast::UseTree = {
    <path:(<Ident> "::")> <tree:UseTree> => ast::UseTree::Path(path, Box::new(tree)),
    <group:("{" <Comma<UseTree>> "}")> => ast::UseTree::Group(group),
    <name:Ident> As <rename:Ident> => ast::UseTree::Rename(name, rename),
    "*" => ast::UseTree::Glob,
    Ident => ast::UseTree::Name(<>),
};

pub Item: ast::Item = {
    <vis:Visibility?> Const <ident:Ident> ":" <ty:Type> "=" <expr:Expr> ";" => ast::Item::Const(vis.unwrap_or_default(), ident, ty, expr),

    <vis:Visibility?> Mod <ident:Ident> "{" <items:Item*> "}" => ast::Item::Mod(vis.unwrap_or_default(), ident, Some(ast::Implicit(items))),
    <vis:Visibility?> Mod <ident:Ident> ";" => ast::Item::Mod(vis.unwrap_or_default(), ident, None),

    <vis:Visibility?> Fn <sig:Sig> <block:Block> => ast::Item::Fn(vis.unwrap_or_default(), sig, block),

    <vis:Visibility?> TokenType <ident:Ident> <generics:Generics?> "=" <ty:Type> ";" => ast::Item::Type(vis.unwrap_or_default(), ident, generics.unwrap_or_default(), ty),

    <vis:Visibility?> Struct <ident:Ident> <generics:Generics?> <fields:Fields> => ast::Item::Struct(vis.unwrap_or_default(), ident, generics.unwrap_or_default(), fields),
    <vis:Visibility?> Entity <ident:Ident> <generics:Generics?> <fields:Fields> => ast::Item::Struct(vis.unwrap_or_default(), ident, generics.unwrap_or_default(), fields),
    <vis:Visibility?> Enum <ident:Ident> <generics:Generics?> "{" <variants:Comma<Variant>> "}" => ast::Item::Enum(vis.unwrap_or_default(), ident, generics.unwrap_or_default(), variants),

    <vis:Visibility?> Bag <ident:Ident> "(" <lits:Comma<Lit>> ")" => ast::Item::Bag(vis.unwrap_or_default(), ident, lits),
    <vis:Visibility?> Ring <ident:Ident> "(" <begin:Lit> ".." <inclusive:"="?> <end:Lit> ")" => ast::Item::Ring(vis.unwrap_or_default(), ident, begin, end, inclusive.is_some()),

    <vis:Visibility?> Use <colon:"::"?> <tree:UseTree> ";" => ast::Item::Use(vis.unwrap_or_default(), colon.is_some(), tree),
};
