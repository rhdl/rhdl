use rug::{Integer as Int, Float};

use std::str::FromStr;

use crate::ast;

grammar;

/// https://doc.rust-lang.org/reference/tokens.html
match {
    r"///[^\n]*\n" => Docstring,
} else {
    r"//[^\n]*\n" => { },
    r"\s*" => { },
} else {
    "as" => TokAs,
    "break" => TokBreak,
    "const" => TokConst,
    "continue" => TokContinue,
    "crate" => TokCrate,
    "else" => TokElse,
    "enum" => TokEnum,
    "extern" => TokExtern,
    "false" => TokFalse,
    "fn" => TokFn,
    "for" => TokFor,
    "if" => TokIf,
    "impl" => TokImpl,
    "in" => TokIn,
    "let" => TokLet,
    "loop" => TokLoop,
    "match" => TokMatch,
    "mod" => TokMod,
    "move" => TokMove,
    "mut" => TokMut,
    "pub" => TokPub,
    "ref" => TokRef,
    "return" => TokReturn,
    "self" => TokLowerSelf,
    "Self" => TokUpperSelf,
    "static" => TokStatic,
    "struct" => TokStruct,
    "super" => TokSuper,
    "trait" => TokTrait,
    "true" => TokTrue,
    "type" => TokTokenType,
    "unsafe" => TokUnsafe,
    "use" => TokUse,
    "where" => TokWhere,
    "while" => TokWhile,

    "async" => TokAsync,
    "await" => TokAwait,
    "dyn" => TokDyn,

    "abstract" => TokAbstract,
    "become" => TokBecome,
    "box" => TokBox,
    "do" => TokDo,
    "final" => TokFinal,
    "macro" => TokMacro,
    "override" => TokOverride,
    "priv" => TokPriv,
    "typeof" => TokTypeof,
    "unsized" => TokUnsized,
    "virtual" => TokVirtual,
    "yield" => TokYield,
    "try" => TokTry,

    "union" => TokUnion,

    "entity" => TokEntity,
    // "bag" => TokBag,
    // "ring" => TokRing,
    "arch" => TokArch,
    "when" => TokWhen,

    "+" => TokPlus,
    "-" => TokMinus,
    "*" => TokStar,
    "**" => TokStarStar,
    "/" => TokSlash,
    "%" => TokPercent,
    "^" => TokCaret,
    "!" => TokNot,
    "&" => TokAnd,
    "|" => TokOr,
    "&&" => TokAndAnd,
    "||" => TokOrOr,
    "<<" => TokShl,
    ">>" => TokShr,
    "+=" => TokPlusEq,
    "-=" => TokMinusEq,
    "*=" => TokStarEq,
    "**=" => TokStarStarEq,
    "/=" => TokSlashEq,
    "%=" => TokPercentEq,
    "^=" => TokCaretEq,
    "&=" => TokAndEq,
    "|=" => TokOrEq,
    "<<=" => TokShlEq,
    ">>=" => TokShrEq,
    "=" => TokEq,
    "==" => TokEqEq,
    "!=" => TokNe,
    ">" => TokGt,
    "<" => TokLt,
    ">=" => TokGe,
    "<=" => TokLe,
    "@" => TokAt,
    "_" => TokUnderscore,
    "." => TokDot,
    ".." => TokDotDot,
    "..=" => TokDotDotEq,
    "," => TokComma,
    ";" => TokSemi,
    ":" => TokColon,
    "::" => TokPathSep,
    "->" => TokRArrow,
    "=>" => TokFatArrow,
    "#" => TokPound,
    "$" => TokDollar,
    "?" => TokQuestion,
    "[" => TokBracketOpen,
    "]" => TokBracketClose,
    "(" => TokParenOpen,
    ")" => TokParenClose,
    "{" => TokBraceOpen,
    "}" => TokBraceClose,

    "r#crate" => RawCrate,
    "r#self" => RawLowerSelf,
    "r#Self" => RawUpperSelf,
    "r#super" => RawSuper,
    r"(0|[1-9]\d*)" => Integer,
} else {
    r"(?:[a-zA-Z][a-zA-Z0-9_]*|_[a-zA-Z0-9_]+)" => NonKeywordIdentifier,
    r"r#(?:[a-zA-Z][a-zA-Z0-9_]*|_[a-zA-Z0-9_]+)" => RawIdentifier,
    r"(0|[1-9]\d*(?:_\d+)*)" => IntegerForLiteral,
    r"0d\d+(?:_\d+)*" => DecimalInteger,
    r"0x[0-9a-fA-F]+(?:_[0-9a-fA-F]+)*" => HexInteger,
    r"0o[0-7]+(?:_[0-7]+)*" => OctalInteger,
    r"0b[01]+(?:_[01]+)*" => BinaryInteger,
    r"(?:2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36)#[a-zA-Z0-9]+(?:_[a-zA-Z0-9]+)*" => BaseInteger,
    r"(?:\d+\.\d*|\d*\.\d+|\d+)(?:[eE][-+]?\d+)?f(?:16|32|64|80|128|256)" => FloatingPoint,
}

As = <left:@L> TokAs => ast::token::As { left };
Break = <left:@L> TokBreak => ast::token::Break { left };
Const = <left:@L> TokConst => ast::token::Const { left };
Continue = <left:@L> TokContinue => ast::token::Continue { left };
Crate = <left:@L> TokCrate => ast::token::Crate { left };
Else = <left:@L> TokElse => ast::token::Else { left };
Enum = <left:@L> TokEnum => ast::token::Enum { left };
Extern = <left:@L> TokExtern => ast::token::Extern { left };
False = <left:@L> TokFalse => ast::token::False { left };
Fn = <left:@L> TokFn => ast::token::Fn { left };
For = <left:@L> TokFor => ast::token::For { left };
If = <left:@L> TokIf => ast::token::If { left };
Impl = <left:@L> TokImpl => ast::token::Impl { left };
In = <left:@L> TokIn => ast::token::In { left };
Let = <left:@L> TokLet => ast::token::Let { left };
Loop = <left:@L> TokLoop => ast::token::Loop { left };
Match = <left:@L> TokMatch => ast::token::Match { left };
Mod = <left:@L> TokMod => ast::token::Mod { left };
Move = <left:@L> TokMove => ast::token::Move { left };
Mut = <left:@L> TokMut => ast::token::Mut { left };
Pub = <left:@L> TokPub => ast::token::Pub { left };
Ref = <left:@L> TokRef => ast::token::Ref { left };
Return = <left:@L> TokReturn => ast::token::Return { left };
LowerSelf = <left:@L> TokLowerSelf => ast::token::LowerSelf { left };
UpperSelf = <left:@L> TokUpperSelf => ast::token::UpperSelf { left };
Static = <left:@L> TokStatic => ast::token::Static { left };
Struct = <left:@L> TokStruct => ast::token::Struct { left };
Super = <left:@L> TokSuper => ast::token::Super { left };
Trait = <left:@L> TokTrait => ast::token::Trait { left };
True = <left:@L> TokTrue => ast::token::True { left };
TokenType = <left:@L> TokTokenType => ast::token::TokenType { left };
Unsafe = <left:@L> TokUnsafe => ast::token::Unsafe { left };
Use = <left:@L> TokUse => ast::token::Use { left };
Where = <left:@L> TokWhere => ast::token::Where { left };
While = <left:@L> TokWhile => ast::token::While { left };

Async = <left:@L> TokAsync => ast::token::Async { left };
Await = <left:@L> TokAwait => ast::token::Await { left };
Dyn = <left:@L> TokDyn => ast::token::Dyn { left };

Abstract = <left:@L> TokAbstract => ast::token::Abstract { left };
Become = <left:@L> TokBecome => ast::token::Become { left };
Box = <left:@L> TokBox => ast::token::Box { left };
Do = <left:@L> TokDo => ast::token::Do { left };
Final = <left:@L> TokFinal => ast::token::Final { left };
Macro = <left:@L> TokMacro => ast::token::Macro { left };
Override = <left:@L> TokOverride => ast::token::Override { left };
Priv = <left:@L> TokPriv => ast::token::Priv { left };
Typeof = <left:@L> TokTypeof => ast::token::Typeof { left };
Unsized = <left:@L> TokUnsized => ast::token::Unsized { left };
Virtual = <left:@L> TokVirtual => ast::token::Virtual { left };
Yield = <left:@L> TokYield => ast::token::Yield { left };
Try = <left:@L> TokTry => ast::token::Try { left };

Union = <left:@L> TokUnion => ast::token::Union { left };

Entity = <left:@L> TokEntity => ast::token::Entity { left };
// Bag = <left:@L> TokBag => ast::token::Bag { left };
// Ring = <left:@L> TokRing => ast::token::Ring { left };
Arch = <left:@L> TokArch => ast::token::Arch { left };
When = <left:@L> TokWhen => ast::token::When { left };

Plus = <left:@L> TokPlus => ast::Token::Plus { left };
Minus = <left:@L> TokMinus => ast::Token::Minus { left };
Star = <left:@L> TokStar => ast::Token::Star { left };
StarStar = <left:@L> TokStarStar => ast::Token::StarStar { left };
Slash = <left:@L> TokSlash => ast::Token::Slash { left };
Percent = <left:@L> TokPercent => ast::Token::Percent { left };
Caret = <left:@L> TokCaret => ast::Token::Caret { left };
Not = <left:@L> TokNot => ast::Token::Not { left };
And = <left:@L> TokAnd => ast::Token::And { left };
Or = <left:@L> TokOr => ast::Token::Or { left };
AndAnd = <left:@L> TokAndAnd => ast::Token::AndAnd { left };
OrOr = <left:@L> TokOrOr => ast::Token::OrOr { left };
Shl = <left:@L> TokShl => ast::Token::Shl { left };
Shr = <left:@L> TokShr => ast::Token::Shr { left };
PlusEq = <left:@L> TokPlusEq => ast::Token::PlusEq { left };
MinusEq = <left:@L> TokMinusEq => ast::Token::MinusEq { left };
StarEq = <left:@L> TokStarEq => ast::Token::StarEq { left };
StarStarEq = <left:@L> TokStarStarEq => ast::Token::StarStarEq { left };
SlashEq = <left:@L> TokSlashEq => ast::Token::SlashEq { left };
PercentEq = <left:@L> TokPercentEq => ast::Token::PercentEq { left };
CaretEq = <left:@L> TokCaretEq => ast::Token::CaretEq { left };
AndEq = <left:@L> TokAndEq => ast::Token::AndEq { left };
OrEq = <left:@L> TokOrEq => ast::Token::OrEq { left };
ShlEq = <left:@L> TokShlEq => ast::Token::ShlEq { left };
ShrEq = <left:@L> TokShrEq => ast::Token::ShrEq { left };
Eq = <left:@L> TokEq => ast::Token::Eq { left };
EqEq = <left:@L> TokEqEq => ast::Token::EqEq { left };
Ne = <left:@L> TokNe => ast::Token::Ne { left };
Gt = <left:@L> TokGt => ast::Token::Gt { left };
Lt = <left:@L> TokLt => ast::Token::Lt { left };
Ge = <left:@L> TokGe => ast::Token::Ge { left };
Le = <left:@L> TokLe => ast::Token::Le { left };
At = <left:@L> TokAt => ast::Token::At { left };
Underscore = <left:@L> TokUnderscore => ast::Token::Underscore { left };
Dot = <left:@L> TokDot => ast::Token::Dot { left };
DotDot = <left:@L> TokDotDot => ast::Token::DotDot { left };
DotDotEq = <left:@L> TokDotDotEq => ast::Token::DotDotEq { left };
Comma = <left:@L> TokComma => ast::Token::Comma { left };
Semi = <left:@L> TokSemi => ast::Token::Semi { left };
Colon = <left:@L> TokColon => ast::Token::Colon { left };
PathSep = <left:@L> TokPathSep => ast::Token::PathSep { left };
RArrow = <left:@L> TokRArrow => ast::Token::RArrow { left };
FatArrow = <left:@L> TokFatArrow => ast::Token::FatArrow { left };
Pound = <left:@L> TokPound => ast::Token::Pound { left };
Dollar = <left:@L> TokDollar => ast::Token::Dollar { left };
Question = <left:@L> TokQuestion => ast::Token::Question { left };
BracketOpen = <left:@L> TokBracketOpen => ast::Token::BracketOpen { left };
BracketClose = <left:@L> TokBracketClose => ast::Token::BracketClose { left };
ParenOpen = <left:@L> TokParenOpen => ast::Token::ParenOpen { left };
ParenClose = <left:@L> TokParenClose => ast::Token::ParenClose { left };
BraceOpen = <left:@L> TokBraceOpen => ast::Token::BraceOpen { left };
BraceClose = <left:@L> TokBraceClose => ast::Token::BraceClose { left };


/// https://doc.rust-lang.org/reference/identifiers.html
Identifier: &'input str = { NonKeywordIdentifier, RawIdentifier };
Ident: ast::Ident = <left:@L> <ident:Identifier> <right:@R> => ast::Ident {
    inner: ident.to_string(),
    span: ast::Span(left, right),
};

// i.e. 1_234_567_890
Int: Int = <left:@L> <val:Integer> <right:@R> => Int::parse(val).unwrap().into();

pub IntLit: ast::Lit = {
    <left:@L> <val:Int> <right:@R> => ast::Lit::Int { val: val.clone(), suffix: None, raw: val.to_string(), span: ast::Span(left, right), },

    <left:@L> <val:IntegerForLiteral> <right: @R> => {
        ast::Lit::Int {
            val: Int::parse(val).unwrap().into(),
            suffix: None,
            raw: val.to_string(),
            span: ast::Span(left, right),
        }
    },

    // i.e. 0d123
    <left:@L> <val:DecimalInteger> <right: @R> => {
        const BASE_CHAR: char = 'd';
        const BASE: i32 = 10;
        ast::Lit::Int {
            val: Int::parse_radix(&val.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            suffix: None,
            raw: val.to_string(),
            span: ast::Span(left, right),
        }
    },

    // i.e. 0xC0FFEE_CAFE
    <left:@L> <val:HexInteger> <right: @R> => {
        const BASE_CHAR: char = 'x';
        const BASE: i32 = 16;
        ast::Lit::Int {
            val: Int::parse_radix(&val.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            suffix: None,
            raw: val.to_string(),
            span: ast::Span(left, right),
        }
    },

    // i.e. 0o72
    <left:@L> <val:OctalInteger> <right: @R> => {
        const BASE_CHAR: char = 'o';
        const BASE: i32 = 8;
        ast::Lit::Int {
            val: Int::parse_radix(&val.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            suffix: None,
            raw: val.to_string(),
            span: ast::Span(left, right),
        }
    },

    // i.e. 0b00110010_00101011_00110010_00111101_00110101
    <left:@L> <val:BinaryInteger> <right: @R> => {
        const BASE_CHAR: char = 'b';
        const BASE: i32 = 2;
        ast::Lit::Int {
            val: Int::parse_radix(&val.split(BASE_CHAR).nth(1).unwrap(), BASE).unwrap().into(),
            suffix: None,
            raw: val.to_string(),
            span: ast::Span(left, right),
        }
    },

    // i.e. 36#HI, an Int in base 36
    <left:@L> <val:BaseInteger> <right: @R> => {
        const BASE_CHAR: char = '#';
        let base = val.split(BASE_CHAR).next().map(i32::from_str).unwrap().unwrap();
        ast::Lit::Int {
            val: Int::parse_radix(&val.split(BASE_CHAR).nth(1).unwrap(), base).unwrap().into(),
            suffix: None,
            raw: val.to_string(),
            span: ast::Span(left, right),
        }
    },
};

pub Float: ast::Lit = <left:@L> <val:FloatingPoint> <right: @R> => {
    let format = val.split('f').nth(1).map(usize::from_str).unwrap().unwrap();
    let precision = match format {
        16 => 11,
        32 => 24,
        64 => 53,
        80 => 64,
        128 => 113,
        256 => 237,
        _ => unreachable!()
    };
    let float = Float::parse(val.split('f').next().unwrap()).unwrap();
    ast::Lit::Float {
        val: Float::with_val(precision, float),
        suffix: None,
        raw: val.to_string(),
        span: ast::Span(left, right),
    }
};

Lit: ast::Lit = {
    IntLit,
    Float,
};


PunctTrail<T, P>: ast::Punctuated<T, P> = {
    <mut inner:(T P)*> <last:T?> => {
        ast::Punctuated {
            inner,
            last: last.map(Box::new)
        }
    }
};

PunctMustTrail<T, P>: ast::Punctuated<T, P> = {
    <mut inner:(T P)*> => {
        ast::Punctuated {
            inner,
            last: None
        }
    }
};

PunctNoTrail<T, P>: ast::Punctuated<T, P> = {
    <mut inner:(T P)*> <last:T> => {
        ast::Punctuated {
            inner,
            last: Some(Box::new(last))
        }
    }
};

Box<T>: Box<T> = T => Box::new(<>);

/// https://doc.rust-lang.org/reference/paths.html#simple-paths
Path: ast::SimplePath = <leading_sep:PathSep?> <segments:PunctNoTrail<PathSegment, PathSep>> => {
    ast::SimplePath {
        leading_sep,
        segments
    }
};

PathSegment: ast::Ident = {
    Ident,
    <left:@L> <ident:LowerSelf> <right:@R> => ast::Ident { inner: ident.to_string(), span: ast::Span(left, right) },
    <left:@L> <ident:Super> <right:@R> => ast::Ident { inner: ident.to_string(), span: ast::Span(left, right) },
    <left:@L> <ident:Crate> <right:@R> => ast::Ident { inner: ident.to_string(), span: ast::Span(left, right) },
};

pub File: Vec<ast::Item> = Item* => <>;

ItemConst: ast::ItemConst = <vis:Visibility?> <const_token:Const> <ident:Ident> <colon:Colon> <ty:Type> <eq:Eq> <expr:Expr> <semi:Semi> => ast::ItemConst {
    vis,
    const_token,
    ident,
    colon,
    ty,
    eq,
    expr,
    semi
};
ItemFn: ast::ItemFn = <vis:Visibility?> <fn_token:Fn> <sig:Sig> <block:Block> => ast::ItemFn {
    vis,
    fn_token,
    sig,
    block
};

/// https://doc.rust-lang.org/reference/items.html
Item: ast::Item = {
    /// https://doc.rust-lang.org/reference/items/modules.html
    <vis:Visibility?> <mod_token:Mod> <ident:Ident> <brace_open:BraceOpen> <items:Item*> <brace_close:BraceClose> => ast::Item::Mod(
        ast::ItemMod {
            vis,
            mod_token,
            ident,
            content: ast::ModContent::Here(
                ast::ModContentHere {
                    brace_open,
                    items,
                    brace_close
                }
            )
        }
    ),
    <vis:Visibility?> <mod_token:Mod> <ident:Ident> <semi:Semi> => ast::Item::Mod(
        ast::ItemMod {
            vis,
            mod_token,
            ident,
            content: ast::ModContent::File(
                ast::ModContentFile { semi }
            )
        }
    ),

    /// https://doc.rust-lang.org/reference/items/use-declarations.html
    <vis:Visibility?> <use_token:Use> <tree:UseTree> <semi:Semi> => ast::Item::Use(
        ast::ItemUse {
            vis,
            use_token,
            tree,
            semi
        }
    ),

    /// https://doc.rust-lang.org/reference/items/constant-items.html
    ItemConst => ast::Item::Const(<>),

    /// https://doc.rust-lang.org/reference/items/functions.html
    ItemFn => ast::Item::Fn(<>),

    /// https://doc.rust-lang.org/reference/items/type-aliases.html
    <vis:Visibility?> <type_token:TokenType> <ident:Ident> <generics:Generics?> <eq:Eq> <ty:Type> <semi:Semi> => ast::Item::Type(
        ast::ItemType {
            vis,
            type_token,
            ident,
            generics,
            eq,
            ty,
            semi
        }
    ),

    /// https://doc.rust-lang.org/reference/items/structs.html
    <vis:Visibility?> <struct_token:Struct> <ident:Ident> <generics:Generics?> <fields:StructFields> => ast::Item::Struct(
        ast::ItemStruct {
            vis,
            struct_token,
            ident,
            generics,
            fields,
            semi
        }
    ),

    /// https://doc.rust-lang.org/reference/items/enumerations.html
    <vis:Visibility?> <enum_token:Enum> <ident:Ident> <generics:Generics?> <brace_open:BraceOpen> <variants:PunctTrail<Variant, Comma>> <brace_close:BraceClose> => ast::Item::Enum(
        ast::ItemEnum {
            vis,
            enum_token,
            ident,
            generics,
            brace_open,
            variants,
            brace_close
        }
    ),

    /// https://doc.rust-lang.org/reference/items/implementations.html
    <impl_token:Impl> <generics:Generics?> <of:(TypePath For)?> <ty:Type> <brace_open:BraceOpen> <items:ImplItem*> <brace_close:BraceClose> => ast::Item::Impl(
        ast::ItemImpl {
            impl_token,
            generics,
            of,
            ty,
            brace_open,
            items,
            brace_close
        }
    ),

    <vis:Visibility?> <entity:Entity> <ident:Ident> <generics:Generics?> <ports:Ports> => ast::Item::Entity(
        ast::ItemEntity {
            vis,
            entity,
            ident,
            generics,
            ports
        }
    ),
    // <vis:Visibility?> <bag:Bag> <ident:Ident> <brace_open:BraceOpen> <literals:PunctTrail<Lit, Comma>> <brace_close:BraceClose> => ast::Item::Bag(
    //     ast::ItemBag {
    //         vis,
    //         bag,
    //         brace_open,
    //         literals,
    //         brace_close
    //     }
    // ),
    // <vis:Visibility?> <ring:Ring> <ident:Ident> <eq:Eq> <range:RangeExpression> <semi:Semi> => ast::Item::Ring(
    //     ast::ItemRing {
    //         vis,
    //         ring,
    //         ident,
    //         eq,
    //         range,
    //         semi
    //     }
    // ),
};

/// https://doc.rust-lang.org/reference/items/use-declarations.html
UseTree: ast::UseTree = {
    UseLeaf,
    <path:UseTreePath> <tree:UseLeaf> => ast::UseTree::Path(
        ast::UseTreePath {
            path,
            tree: Box::new(tree)
        }
    ),
};

#[inline]
UseTreePath: ast::SimplePath = <leading_sep:PathSep?> <segments:(PathSegment PathSep)+> => ast::SimplePath { leading_sep, segments };

UseLeaf: ast::UseTree = {
    Star => ast::UseTree::Glob(<>),
    <brace_open:BraceOpen> <tress:PunctTrail<UseTree, Comma>> <brace_close:BraceClose> => ast::UseTree::Group(
        ast::UseTreeGroup {
            brace_open,
            trees,
            brace_close
        }
    ),
    <name:PathSegment> <as_token:As> <rename:Ident> => ast::UseTree::Rename(
        ast::UseTreeRename {
            name,
            as_token,
            rename
        }
    ),
    PathSegment => ast::UseTree::Name(<>),
};

/// https://doc.rust-lang.org/reference/visibility-and-privacy.html
#[inline]
Visibility: ast::Vis = {
    Pub => ast::Vis::Pub(<>),
    <pub_token:Pub> <paren_open:ParenOpen> <crate_token:Crate> <paren_close:ParenClose> => ast::Vis::Crate(
        ast::VisCrate {
            pub_token,
            paren_open,
            crate_token,
            paren_close
        }
    ),
    <pub_token:Pub> <paren_open:ParenOpen> <super_token:Super> <paren_close:ParenClose> => ast::Vis::Super(
        ast::VisSuper {
            pub_token,
            paren_open,
            super_token,
            paren_close
        }
    ),
    <pub_token:Pub> <paren_open:ParenOpen> <self_token:LowerSelf> <paren_close:ParenClose> => ast::Vis::ExplicitInherited(
        ast::VisExplicitInherited {
            pub_token,
            paren_open,
            self_token,
            paren_close
        }
    ),
    <pub_token:Pub> <paren_open:ParenOpen> <in_token:In> <path_token:Path> <paren_close:ParenClose> => ast::Vis::Restricted(
        ast::VisRestricted {
            pub_token,
            paren_open,
            in_token,
            path,
            paren_close
        }
    ),
};

/// https://doc.rust-lang.org/reference/items/functions.html
Sig: ast::Sig = <ident:Ident> <generics:Generics?> <paren_open:ParenOpen> <inputs:FnArgs> <paren_close:ParenClose> <output:(RArrow Type)?> => ast::Sig {
    ident,
    generics,
    paren_open,
    inputs,
    paren_close,
    output
};

FnArgs: ast::Punctuated<ast::FnArg, ast::Comma> = {
    <receiver:LowerSelf> => ast::Punctuated {
        inner: vec![],
        last: receiver,
    },
    <receiver:LowerSelf> <mut args:PunctTrail<FnArg, Comma>> => {
        args.inner.insert(0, receiver)
        args
    },
    PunctTrail<FnArg, Comma>,
};
FnArg: ast::FnArg = PatType => ast::FnArg::Typed(<>);
PatType: ast::PatType = <pat:Pat> <colon:Colon> <ty:Type> => ast::PatType { pat, colon, ty };

/// https://doc.rust-lang.org/reference/items/generics.html
Generics: ast::Generics = <lt:Lt> <params:PunctTrail<GenericParam, Comma>> <gt:Gt> => ast::Generics { lt, params, gt };

GenericParam: ast::GenericParam = {
    <ident:Ident> <bounds:(Colon PunctNoTrail<TypePath, Add>)> <eq:(Eq <Type>)?> => ast::GenericParam::Type(
        ast::GenericParamType {
            ident,
            bounds,
            eq,
        }
    ),
    <const_token:Const> <ident:Ident> <colon:Colon> <ty:Type> <default:(Eq <Bin3>)?> => ast::GenericParam::Const(
        ast::GenericParamConst {
            const_token,
            ident,
            colon,
            ty,
            default
        }
    ),
};

/// https://doc.rust-lang.org/reference/items/structs.html
StructFields: ast::Fields = {
    <brace_open:BraceOpen> <inner:PunctTrail<NamedField, Comma>> <brace_close:BraceClose> => ast::Fields::Named(
        ast::FieldsNamed {
            brace_open,
            inner,
            brace_close
        }
    ),
    <paren_open:ParenOpen> <inner:PunctTrail<UnnamedField, Comma>> <paren_close:ParenClose> <semi:Semi> => ast::Fields::Unnamed(
        ast::FieldsUnnamed {
            paren_open,
            inner,
            paren_close
            semi: Some(semi)
        }
    ),
};
NamedField: ast::NamedField = <vis:Visibility?> <ident:Ident> <colon:Colon> <ty:Type> => ast::NamedField { vis, ident, colon, ty };
UnnamedField: ast::UnnamedField = <vis:Visibility?> <ty:Type> => ast::UnnamedField { vis, ty };

/// https://doc.rust-lang.org/reference/items/enumerations.html
Variant: ast::Variant = {
    <ident:Ident> <fields:EnumFields?> => ast::Variant::Field(
        ast::VariantField {
            ident,
            fields
        }
    ),
    Ident => ast::Variant::Unit(<>),
    <ident:Ident> <eq:Eq> <expr:Expr> => ast::Variant::Discrim(
        ast::VariantDiscrim {
            ident,
            eq,
            expr
        }
    ),
};
EnumFields: ast::Fields = {
    <brace_open:BraceOpen> <inner:PunctTrail<NamedField, Comma>> <brace_close:BraceClose> => ast::Fields::Named(
        ast::FieldsNamed {
            brace_open,
            inner,
            brace_close
        }
    ),
    <paren_open:ParenOpen> <inner:PunctTrail<UnnamedField, Comma>> <paren_close:ParenClose> => ast::Fields::Unnamed(
        ast::FieldsUnnamed {
            paren_open,
            inner,
            paren_close,
            semi: None,
        }
    ),
};

/// https://doc.rust-lang.org/reference/items/implementations.html
ImplItem: ast::ImplItem = {
    ItemConst => ast::ImplItem::Const(<>),
    ItemFn => ast::ImplItem::Fn(<>),
};

/// https://doc.rust-lang.org/reference/expressions/literal-expr.html
LiteralExpression: ast::Expr = Lit => ast::Expr::Lit(<>);
/// https://doc.rust-lang.org/reference/expressions/path-expr.html
PathInExpression: ast::SimplePath = Path;

/// https://doc.rust-lang.org/reference/expressions/block-expr.html
BlockExpression: ast::Expr = Block => ast::Expr::Block(<>);
Block: ast::Block = <brace_open:BraceOpen> <statements:Statements?> <brace_close:BraceClose> => ast::Block {
    brace_open,
    statements,
    brace_close
};

/// https://doc.rust-lang.org/reference/statements.html
Statement: ast::Stmt = {
    /// https://doc.rust-lang.org/reference/statements.html#item-declarations
    Item => ast::Stmt::Item(<>),
    /// https://doc.rust-lang.org/reference/statements.html#let-statements
    <let_token:Let> <pat:Pat> <ty:(Colon Type)?> <init:(Eq Expr)?> <semi:Semi> => ast::Stmt::Local(
        ast::StmtLocal {
            let_token,
            pat,
            ty,
            init,
            semi
        }
    ),
    /// https://doc.rust-lang.org/reference/statements.html#expression-statements
    <expr:ExprStmt> <semi:Semi> => ast::Stmt::Expr {
        ast::StmtExpr {
            expr,
            semi: Some(semi)
        }
    },
    <expr:ExprWithBlock> <semi:Semi?> => ast::Stmt::Expr {
        ast::StmtExpr {
            expr,
            semi,
        }
    }
};

/// https://doc.rust-lang.org/reference/expressions/block-expr.html
Statements: Vec<ast::Stmt> = {
    <Statement+>,
    <mut v:Statement+> <e:ExprStmt> => {
        v.push(ast::Stmt::Expr(e, false));
        v
    },
    ExprStmt => vec![ast::Stmt::Expr(<>, false)],
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#negation-operators
Unary: ast::Expr = {
    <minus:Minus> <expr:ExprWithoutBlockOrOperator> => ast::Expr::Unary(
        ast::ExprUnary {
            op: ast::UnOp::Minus(minus),
            expr: Box::new(expr)
        }
    ),
    <minus:Minus> <expr:ExprWithBlock> => ast::Expr::Unary(
        ast::ExprUnary {
            op: ast::UnOp::Minus(minus),
            expr: Box::new(expr)
        }
    ),

    <not:Not> <expr:ExprWithoutBlockOrOperator> => ast::Expr::Unary(
        ast::ExprUnary {
            op: ast::UnOp::Not(not),
            expr: Box::new(expr)
        }
    ),
    <not:Not> <expr:ExprWithBlock> => ast::Expr::Unary(
        ast::ExprUnary {
            op: ast::UnOp::Not(not),
            expr: Box::new(expr)
        }
    ),

    ExprWithoutBlockOrOperator,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions
Cast: ast::Expr = {
    <expr:Unary> <as_token:As> <ty:Type> => ast::Expr::Cast(
        ast::ExprCast {
            expr: Box::new(expr),
            as_token,
            ty: Box::new(ty)
        }
    ),
    <expr:ExprWithBlock> <as_token:As> <ty:Type> => ast::Expr::Cast(
        ast::ExprCast {
            expr: Box::new(expr),
            as_token,
            ty: Box::new(ty)
        }
    ),

    Unary,
};

Arith0: ast::Expr = {
    <l:Arith0> <op:StarStar> <r:Cast> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::StarStar(op),
            right: Box::new(r)
        }
    ),
    <l:Arith0> <op:StarStar> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::StarStar(op),
            right: Box::new(r)
        }
    ),

    Cast,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators
Arith1: ast::Expr = {
    <l:Arith1> <op:Slash> <r:Arith0> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Slash(op),
            right: Box::new(r)
        }
    ),
    <l:Arith1> <op:Slash> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Slash(op),
            right: Box::new(r)
        }
    ),

    <l:Arith1> <op:Percent> <r:Arith0> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Percent(op),
            right: Box::new(r)
        }
    ),
    <l:Arith1> <op:Percent> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Percent(op),
            right: Box::new(r)
        }
    ),

    <l:Arith1> <op:Star> <r:Arith0> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Star(op),
            right: Box::new(r)
        }
    ),
    <l:Arith1> <op:Star> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Star(op),
            right: Box::new(r)
        }
    ),

    Arith0,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators
Arith2: ast::Expr = {
    <l:Arith2> <op:Plus> <r:Arith1> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Plus(op),
            right: Box::new(r)
        }
    ),
    <l:Arith2> <op:Plus> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Plus(op),
            right: Box::new(r)
        }
    ),

    <l:Arith2> <op:Minus> <r:Arith1> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Minus(op),
            right: Box::new(r)
        }
    ),
    <l:Arith2> <op:Minus> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Minus(op),
            right: Box::new(r)
        }
    ),

    Arith1,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators
Bin0: ast::Expr = {
    <l:Bin0> <op:Shr> <r:Arith2> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Shr(op),
            right: Box::new(r)
        }
    ),
    <l:Bin0> <op:Shr> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Shr(op),
            right: Box::new(r)
        }
    ),

    <l:Bin0> <op:Shl> <r:Arith2> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Shl(op),
            right: Box::new(r)
        }
    ),
    <l:Bin0> <op:Shl> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Shl(op),
            right: Box::new(r)
        }
    ),

    Arith2,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators
Bin1: ast::Expr = {
    <l:Bin1> <op:And> <r:Bin0> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::And(op),
            right: Box::new(r)
        }
    ),
    <l:Bin1> <op:And> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::And(op),
            right: Box::new(r)
        }
    ),

    Bin0,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators
Bin2: ast::Expr = {
    <l:Bin2> <op:Caret> <r:Bin1> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Caret(op),
            right: Box::new(r)
        }
    ),
    <l:Bin2> <op:Caret> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Caret(op),
            right: Box::new(r)
        }
    ),

    Bin1,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators
Bin3: ast::Expr = {
    <l:Bin3> <op:Or> <r:Bin2> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Or(op),
            right: Box::new(r)
        }
    ),
    <l:Bin3> <op:Or> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Or(op),
            right: Box::new(r)
        }
    ),

    Bin2,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#comparison-operators
ComparisonExpression: ast::Expr = {
    <l:Bin3> <op:EqEq> <r:Bin3> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::EqEq(op),
            right: Box::new(r)
        }
    ),
    <l:Bin3> <op:EqEq> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::EqEq(op),
            right: Box::new(r)
        }
    ),

    <l:Bin3> <op:Ne> <r:Bin3> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Ne(op),
            right: Box::new(r)
        }
    ),
    <l:Bin3> <op:Ne> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Ne(op),
            right: Box::new(r)
        }
    ),

    <l:Bin3> <op:Lt> <r:Bin3> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Lt(op),
            right: Box::new(r)
        }
    ),
    <l:Bin3> <op:Lt> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Lt(op),
            right: Box::new(r)
        }
    ),

    <l:Bin3> <op:Le> <r:Bin3> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Le(op),
            right: Box::new(r)
        }
    ),
    <l:Bin3> <op:Le> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Le(op),
            right: Box::new(r)
        }
    ),

    <l:Bin3> <op:Gt> <r:Bin3> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Gt(op),
            right: Box::new(r)
        }
    ),
    <l:Bin3> <op:Gt> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Gt(op),
            right: Box::new(r)
        }
    ),

    <l:Bin3> <op:Ge> <r:Bin3> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Ge(op),
            right: Box::new(r)
        }
    ),
    <l:Bin3> <op:Ge> <r:ExprWithBlock> => ast::Expr::Binary(
        ast::ExprBinary {
            left: Box::new(l),
            op: ast::BinOp::Ge(op),
            right: Box::new(r)
        }
    ),
    Bin3,
};

/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#assignment-expressions
/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#compound-assignment-expressions
AssignExpression: ast::Expr = {
    <l:ComparisonExpression> <op:Eq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::Eq(op),
            right: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:Eq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::Eq(op),
            right: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:PlusEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::PlusEq(op),
            right: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:PlusEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::PlusEq(op),
            right: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:MinusEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::MinusEq(op),
            right: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:MinusEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::MinusEq(op),
            right: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:StarEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::StarEq(op),
            right: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:StarEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::StarEq(op),
            right: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:StarStarEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::StarStarEq(op),
            right: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:StarStarEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::StarStarEq(op),
            right: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:SlashEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::SlashEq(op),
            right: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:SlashEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::SlashEq(op),
            right: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:PercentEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::PercentEq(op),
            right: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:PercentEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::PercentEq(op),
            right: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:AndEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::AndEq(op),
            right: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:AndEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::AndEq(op),
            right: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:OrEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::OrEq(op),
            right: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:OrEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::OrEq(op),
            right: Box::new(r)
        }
    ),
    
    <l:ComparisonExpression> <op:CaretEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::CaretEq(op),
            right: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:CaretEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::CaretEq(op),
            right: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:ShlEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::ShlEq(op),
            right: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:ShlEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::ShlEq(op),
            right: Box::new(r)
        }
    ),

    <l:ComparisonExpression> <op:ShrEq> <r:ComparisonExpression> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::ShrEq(op),
            right: Box::new(r)
        }
    ),
    <l:ComparisonExpression> <op:ShrEq> <r:ExprWithBlock> => ast::Expr::Assign(
        ast::ExprAssign {
            left: Box::new(l),
            op: ast::AssOp::ShrEq(op),
            right: Box::new(r)
        }
    ),

    ComparisonExpression,
};

/// https://doc.rust-lang.org/reference/expressions/grouped-expr.html
GroupedExpression: ast::Expr = <paren_open:ParenOpen> <expr:Expr> <paren_close:ParenClose> => ast::Expr::Grouped(
    ast::ExprGrouped {
        paren_open,
        expr: Box::new(expr),
        paren_close
    }
);

/// https://doc.rust-lang.org/reference/expressions/array-expr.html#array-expressions
ArrayExpression: ast::Expr = {
    <bracket_open:BracketOpen> <init:Expr> <semi:Semi> <repeat:Expr> <bracket_close:BracketClose> => ast::Expr::Repeat(
        ast::ExprRepeat {
            bracket_open,
            init: Box::new(init),
            semi,
            repeat: Box::new(repeat),
            bracket_close
        }
    ),
    <bracket_open:BracketOpen> <elements:PunctTrail<Expr, Comma>> <bracket_close:BracketClose> => ast::Expr::Array(
        ast::ExprArray {
            bracket_open,
            elements,
            bracket_close
        }
    ),
};

/// https://doc.rust-lang.org/reference/expressions/array-expr.html#array-and-slice-indexing-expressions
IndexExpression: ast::Expr = <on:ExprWithoutBlockOrOperator> <bracket_open:BracketOpen> <index:Expr> <bracket_close:BracketClose> => ast::Expr::Index(
    ast::ExprIndex {
        on: Box::new(on),
        bracket_open,
        index: Box::new(index),
        bracket_close
    }
);

/// https://doc.rust-lang.org/reference/expressions/tuple-expr.html#tuple-expressions
TupleExpression: ast::Expr = <paren_open:ParenOpen> <elements:TupleElements?> <paren_close:ParenClose> => ast::Expr::Tuple(
    ast::ExprTuple {
        paren_open,
        elements,
        paren_close
    }
);
TupleElements: Punctuated<ast::Expr, ast::Comma> = <mut inner:(<Expr> Comma)+> <last:Expr?> => {
    ast::Punctuated {
        inner,
        last
    }
};

/// https://doc.rust-lang.org/reference/expressions/tuple-expr.html#tuple-indexing-expressions
TupleIndexingExpression: ast::Expr = {
    <on:ExprWithBlock> <dot:Dot> <unnamed:Int> => ast::Expr::Field(
        ast::ExprField {
            on,
            dot,
            member: ast::Member::Unnamed(unnamed)
        }
    ),
    <on:ExprWithoutBlockOrOperator> <dot:Dot> <unnamed:Int> => ast::Expr::Field(
        ast::ExprField {
            on,
            dot,
            member: ast::Member::Unnamed(unnamed)
        }
    )
};

/// https://doc.rust-lang.org/reference/expressions/struct-expr.html#struct-expressions
StructExpression: ast::Expr = <path:PathInExpression> <brace_open:BraceOpen> <fields:PunctNoTrail<FieldValue, Comma>?> <base:(Comma DotDot Expr)?> <comma:Comma?> <brace_close:BraceClose> => ast::Expr::Struct(
    ast::ExprStruct {
        path,
        brace_open,
        fields,
        base,
        comma,
        brace_close
    }
);

FieldValue: ast::FieldValue = {
    <named:Ident> <expr:(Colon Expr)?> => ast::FieldValue { member: ast::Member::Named(named), expr },
    <unnamed:Int> <expr:(Colon Expr)> => ast::FieldValue { member: ast::Member::Unnamed(unnamed), expr: Some(expr) },
};

/// https://doc.rust-lang.org/reference/expressions/call-expr.html
CallExpression: ast::Expr = <on:Box<ExprWithoutFieldOrBlock>> <paren_open:ParenOpen> <args:PunctTrail<Expr, Comma>> <paren_close:ParenClose> => ast::Expr::Call(
    ast::ExprCall {
        on,
        paren_open,
        args,
        paren_close
    }
);

/// https://doc.rust-lang.org/reference/expressions/method-call-expr.html
MethodCallExpression: ast::Expr = {
    <on:Box<ExprWithoutBlockOrOperator>> <dot:Dot> <method:Ident> <paren_open:ParenOpen> <args:PunctTrail<Expr, Comma>> <paren_close:ParenClose> => ast::Expr::MethodCall(
        ast::ExprMethodCall {
            on,
            dot,
            method,
            paren_open,
            args,
            paren_close
        }    
    ),
    <on:Box<ExprWithoutBlockOrOperator>> <dot:Dot> <method:Ident> <paren_open:ParenOpen> <args:PunctTrail<Expr, Comma>> <paren_close:ParenClose> => ast::Expr::MethodCall(
        ast::ExprMethodCall {
            on,
            dot,
            method,
            paren_open,
            args,
            paren_close
        }    
    )
};

/// https://doc.rust-lang.org/reference/expressions/field-expr.html
FieldExpression: ast::Expr = {
    <on:Box<ExprWithBlock>> <dot:Dot> <named:Ident> => ast::Expr::Field(
        ast::ExprField {
            on,
            dot,
            member: ast::Member::Named(named)
        }
    ),
    <on:Box<ExprWithoutBlockOrOperator>> <dot:Dot> <named:Ident> => ast::Expr::Field(
        ast::ExprField {
            on,
            dot,
            member: ast::Member::Named(named)
        }
    )
};

// todo: closure expression

IteratorLoopExpression: ast::Expr = {
    <for_token:For> <pat:Box<Pat>> <in_token:In> <expr:Box<ExprIf>> <block:Block> => ast::Expr::For(
        ast::ExprFor {
            for_token,
            pat,
            in_token,
            expr,
            block
        }
    )
};

/// https://doc.rust-lang.org/reference/expressions/range-expr.html
RangeExpression: ast::Expr = {
    <left:Box<LiteralExpression>?> <dotdot:DotDot> <right:Box<LiteralExpression>?> => ast::Expr::Range(
        ast::ExprRange {
            left,
            range_type: ast::RangeType::HalfOpen(dotdot),
            right
        }
    ),
    <left:Box<LiteralExpression>?> <dotdoteq:DotDotEq> <right:Box<LiteralExpression>?> => ast::Expr::Range(
        ast::ExprRange {
            left,
            range_type: ast::RangeType::Closed(dotdoteq),
            right
        }
    )
};

// todo: if let expression
/// https://doc.rust-lang.org/reference/expressions/if-expr.html
IfExpression: ast::Expr = {
    <if_token:If> <expr:Expr> <block:Block> <else_token:(Else Box<IfExpression>)> => ast::Expr::If(
        ast::ExprIf {
            if_token,
            expr,
            block,
            else_token
        }
    ),
    <if_token:If> <expr:Expr> <block:Block> <else_token:(Else Box<BlockExpression>)> => ast::Expr::If(
        ast::ExprIf {
            if_token,
            expr,
            block,
            else_token
        }
    )
};

/// https://doc.rust-lang.org/reference/expressions/match-expr.html
MatchExpression: ast::Expr = <match_token:Match> <expr:Box<ExprIf>> <brace_open:BraceOpen> <arms:PunctTrail<MatchArm, Comma>> <brace_close:BraceClose> => ast::Expr::Match(
    match_token,
    expr,
    brace_open,
    arms,
    brace_close
);

MatchArm: ast::Arm = {
    <pat:Pat> <guard:(If ExprIf)?> <fat_arrow:FatArrow> <body:Expr> => ast::Arm {
        pat,
        guard,
        fat_arrow,
        body
    },
};

/// https://doc.rust-lang.org/reference/expressions/return-expr.html
ReturnExpression: ast::Expr = <return_token:Return> <expr:Box<Expr>?> => ast::Expr::Return(
    ast::ExprReturn {
        return_token,
        expr
    }
);

ExprWithoutFieldOrBlock: ast::Expr = {
    LiteralExpression,
    PathInExpression => ast::Expr::Path(<>),
    GroupedExpression,
    ArrayExpression,
    IndexExpression,
    TupleExpression,
    TupleIndexingExpression,
    CallExpression,
    MethodCallExpression,
    RangeExpression,
};

ExprWithoutBlockOrOperator: ast::Expr = {
    ExprWithoutFieldOrBlock,
    FieldExpression,
};

ExprStmt: ast::Expr = {
    AssignExpression,
    ReturnExpression,
};

/// https://doc.rust-lang.org/reference/expressions.html
ExprWithBlock: ast::Expr = {
    BlockExpression,
    IfExpression,
    MatchExpression,
    IteratorLoopExpression,
    // StructExpression,
};

ExprIf: ast::Expr = {
    ComparisonExpression,
    ExprWithBlock,
};

/// https://doc.rust-lang.org/reference/expressions.html
pub Expr: ast::Expr = {
    ComparisonExpression,
    ExprWithBlock,
    // TODO: add struct expression to arithmetic tree in a way that it won't conflict with if/match statements
    StructExpression,
};

/// https://doc.rust-lang.org/reference/patterns.html
pub Pat: ast::Pat = {
    /// https://doc.rust-lang.org/reference/patterns.html#literal-patterns
    Lit => ast::Pat::Lit(<>),
    /// https://doc.rust-lang.org/reference/patterns.html#identifier-patterns and https://doc.rust-lang.org/reference/patterns.html#path-patterns
    PathInExpression => {
        if <>.leading_sep.is_none() && <>.segments.len() == 1 {
            if let Some(segment) = <>.segments.last {
                ast::Pat::Ident(segment.clone())
            } else {
                ast::Pat::Path(<>)
            }
        } else {
            ast::Pat::Path(<>)
        }
    },
    /// https://doc.rust-lang.org/reference/patterns.html#wildcard-pattern
    Underscore => ast::Pat::Wildcard(<>),
    /// https://doc.rust-lang.org/reference/patterns.html#range-patterns
    <left:RangePatternBound> <dotdot:DotDot> <right:RangePatternBound> => ast::Pat::Range(
        ast::PatRange {
            left,
            range_type: ast::RangeType::HalfOpen(dotdot),
            right
        }
    ),
    <l:RangePatternBound> <dotdoteq:DotDotEq> <r:RangePatternBound> => ast::Pat::Range(
        ast::PatRange {
            left,
            range_type: ast::RangeType::Closed(dotdoteq),
            right
        }
    ),
    /// https://doc.rust-lang.org/reference/patterns.html#struct-patterns
    <path:PathInExpression> <brace_open:BraceOpen> <elems:StructPatternElements> <brace_close:BraceClose> => ast::Pat::Struct(
        ast::PatStruct {
            path,
            brace_open,
            fields: elems.0,
            remaining: elems.1,
            brace_close
        }
    ),
    /// https://doc.rust-lang.org/reference/patterns.html#tuple-struct-patterns
    <path: PathInExpression> <paren_open:ParenOpen> <subpats:PunctTrail<Pat, Comma>> <paren_close:ParenClose> => ast::Pat::TupleStruct(
        ast::PatTupleStruct {
            path,
            paren_open,
            subpats,
            rest_subpats: None,
            paren_close
        }
    ),
    <path: PathInExpression> <paren_open:ParenOpen> <left:(<Pat> Comma)*> DotDot Comma <right:PunctTrail<Pat, Comma>> <paren_close:ParenClose> => ast::Pat::TupleStruct(path, ast::Comma(left), Some(right)),
    /// https://doc.rust-lang.org/reference/patterns.html#tuple-patterns and https://doc.rust-lang.org/reference/patterns.html#grouped-patterns
    <paren_open:ParenOpen> <PunctTrail<Pat, Comma>> <paren_close:ParenClose> => ast::Pat::Tuple(<>, None),
    <paren_open:ParenOpen> <left:(<Pat> Comma)*> DotDot Comma <right:PunctTrail<Pat, Comma>> <paren_close:ParenClose> => ast::Pat::Tuple(ast::Comma(left), Some(right)),
    /// https://doc.rust-lang.org/reference/patterns.html#slice-patterns
    <bracket_open:BracketOpen> <PunctTrail<Pat, Comma>> <bracket_close:BracketClose> => ast::Pat::Slice(<>),
};

RangePatternBound: ast::Expr = {
    LiteralExpression,
    // GroupedExpression,
    PathInExpression => ast::Expr::Path(<>),
};

StructPatternElements: (Option<ast::PunctTrail<ast::StructPatternField, ast::Comma>>, Option<DotDot>) = {
    DotDot => (None, Some(<>)),
    PunctTrail<StructPatternField, Comma> => (Some(<>), None),
    <fields:PunctMustTrail<StructPatternField, Comma>> <dotdot:DotDot> => (Some(fields), Some(dotdot)),
};

StructPatternField: ast::StructPatternField = {
    <index:Int> <colon:Colon> <pat:Box<Pat>> => ast::StructPatternField::TuplePat(
        ast::StructPatternFieldTuplePat {
            index,
            colon,
            pat
        }
    ),
    <ident:Ident> <colon:Colon> <pat:Box<Pat>> => ast::StructPatternField::IdentPat(
        ast::StructPatternFieldIdentPat {
            ident,
            colon,
            pat
        }
    ),
    Ident => ast::StructPatternField::Ident(<>),
};

/// https://doc.rust-lang.org/reference/types.html
pub Type: ast::Type = {
    /// https://doc.rust-lang.org/reference/types.html#parenthesized-types
    <paren_open:ParenOpen> <inner:Box<Type>> <paren_close:ParenClose> => ast::Type::Parenthesized(
        ast::TypeParenthesized {
            paren_open,
            inner,
            paren_close
        }
    ),

    /// https://doc.rust-lang.org/reference/paths.html#paths-in-types
    TypePath => ast::Type::Path(<>),

    /// https://doc.rust-lang.org/reference/types/tuple.html#tuple-types
    <paren_open:ParenOpen> <tys: PunctTrail<Type, Comma>> <paren_close:ParenClose> => ast::Type::Tuple(
        ast::TypeTuple {
            paren_open,
            tys,
            paren_close
        }
    ),

    /// https://doc.rust-lang.org/reference/types/array.html
    <bracket_open:BracketOpen> <ty:Box<Type>> <semi:Semi> <lit:IntLit> <bracket_close:BracketClose> => ast::Type::Array(
        ast::TypeArray {
            bracket_open,
            ty,
            semi,
            lit,
            bracket_close
        }
    ),

    /// https://doc.rust-lang.org/reference/types/slice.html
    <bracket_open:BracketOpen> <ty:Box<Type>> <bracket_close:BracketClose> => ast::Type::Slice(
        ast::TypeSlice {
            bracket_open,
            ty,
            bracket_close
        }
    ),

    /// https://doc.rust-lang.org/reference/types/inferred.html
    Underscore => ast::Type::Infer(<>),

    /// https://doc.rust-lang.org/reference/types/function-pointer.html
    /// TODO: support named params "MaybeNamedParam"
    <fn_token:Fn> <paren_open:ParenOpen> <args:PunctComma<Type>> <paren_close:ParenClose> <ret:(RArrow Box<Type>)?> => ast::Type::Fn(
        ast::TypeFn {
            fn_token,
            paren_open,
            args,
            paren_close,
            ret
        }
    ),
};
TypePath: ast::SimplePath = PathInExpression;
